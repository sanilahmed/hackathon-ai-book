"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[6502],{1788:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>t,default:()=>p,frontMatter:()=>l,metadata:()=>a,toc:()=>c});var i=n(4848),r=n(8453);const l={},t="Nodes and Topics in ROS 2",a={id:"modules/ros2-nervous-system/nodes-topics",title:"Nodes and Topics in ROS 2",description:"Understanding Nodes",source:"@site/docs/modules/ros2-nervous-system/nodes-topics.md",sourceDirName:"modules/ros2-nervous-system",slug:"/modules/ros2-nervous-system/nodes-topics",permalink:"/hackathon-ai-book/modules/ros2-nervous-system/nodes-topics",draft:!1,unlisted:!1,editUrl:"https://github.com/sanilahmed/hackathon-ai-book/tree/main/docs/modules/ros2-nervous-system/nodes-topics.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"ROS 2 Architecture Concepts",permalink:"/hackathon-ai-book/modules/ros2-nervous-system/architecture"},next:{title:"URDF Modeling for Humanoid Robots",permalink:"/hackathon-ai-book/modules/ros2-nervous-system/urdf-modeling"}},o={},c=[{value:"Understanding Nodes",id:"understanding-nodes",level:2},{value:"Creating a Node",id:"creating-a-node",level:3},{value:"Topics and Message Passing",id:"topics-and-message-passing",level:2},{value:"Message Types",id:"message-types",level:3},{value:"Publisher Example",id:"publisher-example",level:3},{value:"Subscriber Example",id:"subscriber-example",level:3},{value:"Quality of Service (QoS) Settings",id:"quality-of-service-qos-settings",level:2},{value:"Advanced Topic Patterns",id:"advanced-topic-patterns",level:2},{value:"Latching (Transient Local Durability)",id:"latching-transient-local-durability",level:3},{value:"Multiple Publishers and Subscribers",id:"multiple-publishers-and-subscribers",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Practical Exercise",id:"practical-exercise",level:2},{value:"Summary",id:"summary",level:2},{value:"Learning Check",id:"learning-check",level:2}];function d(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h1,{id:"nodes-and-topics-in-ros-2",children:"Nodes and Topics in ROS 2"}),"\n",(0,i.jsx)(s.h2,{id:"understanding-nodes",children:"Understanding Nodes"}),"\n",(0,i.jsx)(s.p,{children:"Nodes are the fundamental computational elements in ROS 2. Each node is an independent process that performs specific functions within the robotic system. Nodes are designed to be modular, allowing for flexible system architectures where each component has a single, well-defined responsibility."}),"\n",(0,i.jsx)(s.h3,{id:"creating-a-node",children:"Creating a Node"}),"\n",(0,i.jsxs)(s.p,{children:["In ROS 2, nodes are created by inheriting from the ",(0,i.jsx)(s.code,{children:"Node"})," class provided by the client libraries (rclpy for Python, rclcpp for C++):"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Python Example:"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\n\nclass MinimalPublisher(Node):\n    def __init__(self):\n        super().__init__('minimal_publisher')\n        self.publisher_ = self.create_publisher(String, 'topic', 10)\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = f'Hello World: {self.i}'\n        self.publisher_.publish(msg)\n        self.get_logger().info(f'Publishing: \"{msg.data}\"')\n        self.i += 1\n"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"C++ Example:"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:'#include "rclcpp/rclcpp.hpp"\n#include "std_msgs/msg/string.hpp"\n\nclass MinimalPublisher : public rclcpp::Node\n{\npublic:\n    MinimalPublisher() : Node("minimal_publisher"), count_(0)\n    {\n        publisher_ = this->create_publisher<std_msgs::msg::String>("topic", 10);\n        timer_ = this->create_wall_timer(\n            500ms, std::bind(&MinimalPublisher::timer_callback, this));\n    }\n\nprivate:\n    void timer_callback()\n    {\n        auto message = std_msgs::msg::String();\n        message.data = "Hello World: " + std::to_string(count_++);\n        RCLCPP_INFO(this->get_logger(), "Publishing: \'%s\'", message.data.c_str());\n        publisher_->publish(message);\n    }\n    rclcpp::TimerBase::SharedPtr timer_;\n    rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;\n    size_t count_;\n};\n'})}),"\n",(0,i.jsx)(s.h2,{id:"topics-and-message-passing",children:"Topics and Message Passing"}),"\n",(0,i.jsx)(s.p,{children:"Topics are named buses that allow nodes to exchange messages. The communication follows a publish-subscribe pattern where publishers send messages to topics and subscribers receive messages from topics."}),"\n",(0,i.jsx)(s.h3,{id:"message-types",children:"Message Types"}),"\n",(0,i.jsxs)(s.p,{children:["ROS 2 defines standard message types in packages like ",(0,i.jsx)(s.code,{children:"std_msgs"}),", ",(0,i.jsx)(s.code,{children:"geometry_msgs"}),", and ",(0,i.jsx)(s.code,{children:"sensor_msgs"}),". Custom message types can also be defined using ",(0,i.jsx)(s.code,{children:".msg"})," files."]}),"\n",(0,i.jsx)(s.h3,{id:"publisher-example",children:"Publisher Example"}),"\n",(0,i.jsx)(s.p,{children:"A publisher node creates a publisher object and sends messages to a topic:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass Talker(Node):\n    def __init__(self):\n        super().__init__('talker')\n        self.publisher = self.create_publisher(String, 'chatter', 10)\n        timer_period = 0.5\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = 'Hello from ROS 2 talker'\n        self.publisher.publish(msg)\n        self.get_logger().info(f'Publishing: {msg.data}')\n"})}),"\n",(0,i.jsx)(s.h3,{id:"subscriber-example",children:"Subscriber Example"}),"\n",(0,i.jsx)(s.p,{children:"A subscriber node creates a subscription object and registers a callback function:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass Listener(Node):\n    def __init__(self):\n        super().__init__('listener')\n        self.subscription = self.create_subscription(\n            String,\n            'chatter',\n            self.listener_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info(f'I heard: {msg.data}')\n"})}),"\n",(0,i.jsx)(s.h2,{id:"quality-of-service-qos-settings",children:"Quality of Service (QoS) Settings"}),"\n",(0,i.jsx)(s.p,{children:"QoS settings allow fine-tuning of communication behavior:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy\n\n# Create a QoS profile for sensor data (best effort, keep last 10)\nsensor_qos = QoSProfile(\n    reliability=ReliabilityPolicy.BEST_EFFORT,\n    history=HistoryPolicy.KEEP_LAST,\n    depth=10\n)\n\n# Create a QoS profile for critical commands (reliable, keep all)\ncommand_qos = QoSProfile(\n    reliability=ReliabilityPolicy.RELIABLE,\n    history=HistoryPolicy.KEEP_ALL\n)\n\npublisher = self.create_publisher(String, 'critical_topic', command_qos)\n"})}),"\n",(0,i.jsx)(s.h2,{id:"advanced-topic-patterns",children:"Advanced Topic Patterns"}),"\n",(0,i.jsx)(s.h3,{id:"latching-transient-local-durability",children:"Latching (Transient Local Durability)"}),"\n",(0,i.jsx)(s.p,{children:"For static data that late-joining subscribers should receive immediately:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:"from rclpy.qos import DurabilityPolicy, QoSProfile\n\nlatching_qos = QoSProfile(\n    durability=DurabilityPolicy.TRANSIENT_LOCAL,\n    history=HistoryPolicy.KEEP_ALL\n)\nlatching_publisher = self.create_publisher(String, 'static_topic', latching_qos)\n"})}),"\n",(0,i.jsx)(s.h3,{id:"multiple-publishers-and-subscribers",children:"Multiple Publishers and Subscribers"}),"\n",(0,i.jsx)(s.p,{children:"ROS 2 supports multiple publishers and subscribers on the same topic:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:"# Multiple publishers can send to the same topic\npub1 = self.create_publisher(String, 'shared_topic', 10)\npub2 = self.create_publisher(String, 'shared_topic', 10)\n\n# Multiple subscribers can receive from the same topic\nsub1 = self.create_subscription(String, 'shared_topic', callback1, 10)\nsub2 = self.create_subscription(String, 'shared_topic', callback2, 10)\n"})}),"\n",(0,i.jsx)(s.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Node Design"}),": Each node should have a single responsibility and be independently testable"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Topic Naming"}),": Use descriptive, consistent naming conventions (e.g., ",(0,i.jsx)(s.code,{children:"/robot_name/sensor_type/data"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Message Frequency"}),": Balance between responsiveness and network load"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"QoS Selection"}),": Choose appropriate QoS settings based on data importance and real-time requirements"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Error Handling"}),": Implement proper error handling for network disconnections and message failures"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"practical-exercise",children:"Practical Exercise"}),"\n",(0,i.jsx)(s.p,{children:"Create a simple publisher-subscriber pair:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:"Implement a publisher that sends sensor readings at 10 Hz"}),"\n",(0,i.jsx)(s.li,{children:"Implement a subscriber that logs the received data"}),"\n",(0,i.jsx)(s.li,{children:"Configure appropriate QoS settings for sensor data"}),"\n",(0,i.jsx)(s.li,{children:"Test the communication using ROS 2 command-line tools"}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(s.p,{children:"Nodes and topics form the foundation of ROS 2 communication. Understanding how to create nodes, define publishers and subscribers, and configure QoS settings is essential for building robust robotic systems. The modular nature of nodes enables flexible system architectures that can be easily extended and maintained."}),"\n",(0,i.jsx)(s.h2,{id:"learning-check",children:"Learning Check"}),"\n",(0,i.jsx)(s.p,{children:"After studying this section, you should be able to:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Create nodes in both Python and C++"}),"\n",(0,i.jsx)(s.li,{children:"Implement publishers and subscribers for message passing"}),"\n",(0,i.jsx)(s.li,{children:"Configure appropriate QoS settings for different use cases"}),"\n",(0,i.jsx)(s.li,{children:"Design effective topic naming conventions"}),"\n",(0,i.jsx)(s.li,{children:"Understand the publish-subscribe communication pattern"}),"\n"]})]})}function p(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>t,x:()=>a});var i=n(6540);const r={},l=i.createContext(r);function t(e){const s=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(l.Provider,{value:s},e.children)}}}]);