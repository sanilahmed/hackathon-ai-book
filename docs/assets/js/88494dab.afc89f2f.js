"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[5823],{5595:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var o=t(4848),r=t(8453);const i={},a="Lab 3.3: Isaac Sim Planning and Control Systems",s={id:"modules/lab-exercises/lab-3-3-planning-control",title:"Lab 3.3: Isaac Sim Planning and Control Systems",description:"Overview",source:"@site/docs/modules/lab-exercises/lab-3-3-planning-control.md",sourceDirName:"modules/lab-exercises",slug:"/modules/lab-exercises/lab-3-3-planning-control",permalink:"/hackathon-ai-book/modules/lab-exercises/lab-3-3-planning-control",draft:!1,unlisted:!1,editUrl:"https://github.com/sanilahmed/hackathon-ai-book/tree/main/docs/modules/lab-exercises/lab-3-3-planning-control.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Lab 3.2: Isaac Sim Perception Systems",permalink:"/hackathon-ai-book/modules/lab-exercises/lab-3-2-perception-systems"},next:{title:"Lab 3.4: Isaac Sim Reinforcement Learning Systems",permalink:"/hackathon-ai-book/modules/lab-exercises/lab-3-4-reinforcement-learning"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Objectives",id:"objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Duration",id:"duration",level:2},{value:"Exercise 1: Path Planning and Navigation",id:"exercise-1-path-planning-and-navigation",level:2},{value:"Step 1: Create a basic navigation environment",id:"step-1-create-a-basic-navigation-environment",level:3},{value:"Step 2: Implement A* path planning algorithm",id:"step-2-implement-a-path-planning-algorithm",level:3},{value:"Exercise 2: Motion Control Systems",id:"exercise-2-motion-control-systems",level:2},{value:"Step 1: Create a motion control system",id:"step-1-create-a-motion-control-system",level:3},{value:"Exercise 3: Advanced Control Systems",id:"exercise-3-advanced-control-systems",level:2},{value:"Step 1: Implement PID controller with feedback",id:"step-1-implement-pid-controller-with-feedback",level:3},{value:"Exercise 4: ROS Integration for Planning and Control",id:"exercise-4-ros-integration-for-planning-and-control",level:2},{value:"Step 1: Create ROS navigation integration",id:"step-1-create-ros-navigation-integration",level:3},{value:"Exercise 5: Behavior Trees for Complex Navigation",id:"exercise-5-behavior-trees-for-complex-navigation",level:2},{value:"Step 1: Implement a behavior tree system",id:"step-1-implement-a-behavior-tree-system",level:3},{value:"Exercise 6: Control System Validation and Testing",id:"exercise-6-control-system-validation-and-testing",level:2},{value:"Step 1: Create control validation tools",id:"step-1-create-control-validation-tools",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:3},{value:"Assessment Questions",id:"assessment-questions",level:2},{value:"Extension Exercises",id:"extension-exercises",level:2},{value:"Summary",id:"summary",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h1,{id:"lab-33-isaac-sim-planning-and-control-systems",children:"Lab 3.3: Isaac Sim Planning and Control Systems"}),"\n",(0,o.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(e.p,{children:"In this lab, you will learn how to implement planning and control systems in Isaac Sim for robotics applications. You'll work with path planning algorithms, trajectory generation, motion control, and integration with Isaac Sim's physics engine. This includes understanding the control architecture, implementing various control strategies, and integrating with ROS for navigation and manipulation tasks."}),"\n",(0,o.jsx)(e.h2,{id:"objectives",children:"Objectives"}),"\n",(0,o.jsx)(e.p,{children:"By the end of this lab, you will be able to:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Implement path planning algorithms in Isaac Sim"}),"\n",(0,o.jsx)(e.li,{children:"Create trajectory generators for robot motion"}),"\n",(0,o.jsx)(e.li,{children:"Implement motion control systems using Isaac Sim's control interface"}),"\n",(0,o.jsx)(e.li,{children:"Integrate planning and control with ROS navigation stack"}),"\n",(0,o.jsx)(e.li,{children:"Implement feedback control for robot motion"}),"\n",(0,o.jsx)(e.li,{children:"Create behavior trees for complex robot behaviors"}),"\n",(0,o.jsx)(e.li,{children:"Validate control performance and stability"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Completion of Lab 3.1: Isaac Sim Setup and Environment"}),"\n",(0,o.jsx)(e.li,{children:"Completion of Lab 3.2: Isaac Sim Perception Systems"}),"\n",(0,o.jsx)(e.li,{children:"Understanding of ROS navigation stack"}),"\n",(0,o.jsx)(e.li,{children:"Basic knowledge of control theory"}),"\n",(0,o.jsx)(e.li,{children:"Experience with Isaac Sim and sensor integration"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"duration",children:"Duration"}),"\n",(0,o.jsx)(e.p,{children:"5-6 hours"}),"\n",(0,o.jsx)(e.h2,{id:"exercise-1-path-planning-and-navigation",children:"Exercise 1: Path Planning and Navigation"}),"\n",(0,o.jsx)(e.h3,{id:"step-1-create-a-basic-navigation-environment",children:"Step 1: Create a basic navigation environment"}),"\n",(0,o.jsxs)(e.p,{children:["Create ",(0,o.jsx)(e.code,{children:"~/isaac_sim_examples/navigation_environment.py"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n# navigation_environment.py\nimport omni\nfrom omni.isaac.core import World\nfrom omni.isaac.core.utils.prims import create_primitive\nfrom omni.isaac.core.utils.viewports import set_camera_view\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\nfrom omni.isaac.core.utils.nucleus import get_assets_root_path\nfrom omni.isaac.core.robots import Robot\nfrom omni.isaac.core.articulations import Articulation\nfrom omni.isaac.core.utils.semantics import add_semantic_data_to_stage\nimport numpy as np\nimport carb\n\nclass NavigationEnvironment:\n    def __init__(self):\n        self.world = World(stage_units_in_meters=1.0)\n        self.robot = None\n        self.setup_environment()\n\n    def setup_environment(self):\n        """Set up navigation environment with obstacles."""\n        # Create ground plane\n        create_primitive(\n            prim_path="/World/GroundPlane",\n            primitive_type="Plane",\n            scale=[20, 20, 1],\n            position=[0, 0, 0]\n        )\n\n        # Create walls to form corridors\n        wall_thickness = 0.2\n        wall_height = 2.0\n\n        # Outer walls\n        create_primitive(\n            prim_path="/World/Wall_North",\n            primitive_type="Cuboid",\n            scale=[20, wall_thickness, wall_height],\n            position=[0, 10, wall_height/2],\n            color=[0.5, 0.5, 0.5]\n        )\n\n        create_primitive(\n            prim_path="/World/Wall_South",\n            primitive_type="Cuboid",\n            scale=[20, wall_thickness, wall_height],\n            position=[0, -10, wall_height/2],\n            color=[0.5, 0.5, 0.5]\n        )\n\n        create_primitive(\n            prim_path="/World/Wall_East",\n            primitive_type="Cuboid",\n            scale=[wall_thickness, 20, wall_height],\n            position=[10, 0, wall_height/2],\n            color=[0.5, 0.5, 0.5]\n        )\n\n        create_primitive(\n            prim_path="/World/Wall_West",\n            primitive_type="Cuboid",\n            scale=[wall_thickness, 20, wall_height],\n            position=[-10, 0, wall_height/2],\n            color=[0.5, 0.5, 0.5]\n        )\n\n        # Create obstacles to form navigation challenges\n        # Create a corridor with obstacles\n        for i in range(5):\n            # Left column of obstacles\n            create_primitive(\n                prim_path=f"/World/Obstacle_Left_{i}",\n                primitive_type="Cylinder",\n                scale=[0.4, 0.4, 1.0],\n                position=[-6, 2*i - 4, 0.5],\n                color=[0.8, 0.2, 0.2]\n            )\n\n            # Right column of obstacles\n            create_primitive(\n                prim_path=f"/World/Obstacle_Right_{i}",\n                primitive_type="Cylinder",\n                scale=[0.4, 0.4, 1.0],\n                position=[6, 2*i - 4, 0.5],\n                color=[0.2, 0.8, 0.2]\n            )\n\n        # Create start and goal markers\n        create_primitive(\n            prim_path="/World/Start",\n            primitive_type="Sphere",\n            scale=[0.3, 0.3, 0.3],\n            position=[-8, 0, 0.15],\n            color=[0, 1, 0]  # Green for start\n        )\n\n        create_primitive(\n            prim_path="/World/Goal",\n            primitive_type="Sphere",\n            scale=[0.3, 0.3, 0.3],\n            position=[8, 0, 0.15],\n            color=[1, 0, 0]  # Red for goal\n        )\n\n        # Create a simple robot\n        self.robot = create_primitive(\n            prim_path="/World/Robot",\n            primitive_type="Cylinder",\n            scale=[0.5, 0.5, 1.0],\n            position=[-8, 0, 0.5],\n            color=[0.1, 0.1, 0.8]  # Blue robot\n        )\n\n    def get_robot_position(self):\n        """Get current robot position."""\n        if self.robot:\n            from pxr import UsdGeom\n            stage = omni.usd.get_context().get_stage()\n            prim = stage.GetPrimAtPath("/World/Robot")\n            xform = UsdGeom.Xformable(prim)\n            transform = xform.ComputeLocalToWorldTransform(omni.usd.get_context().get_time_code())\n            pos = transform.ExtractTranslation()\n            return np.array([pos[0], pos[1], pos[2]])\n        return None\n\n    def move_robot(self, target_position):\n        """Move robot to target position (simplified for demo)."""\n        # In a real implementation, this would use proper kinematics and control\n        if self.robot:\n            from pxr import Gf, UsdGeom\n            stage = omni.usd.get_context().get_stage()\n            prim = stage.GetPrimAtPath("/World/Robot")\n            xform = UsdGeom.Xformable(prim)\n\n            # Set new position\n            new_transform = xform.GetLocalTransformation()\n            new_transform.SetTranslate(Gf.Vec3d(target_position[0], target_position[1], target_position[2]))\n            xform.SetLocalTransformation(new_transform)\n\n    def run_simulation(self, steps=1000):\n        """Run navigation simulation."""\n        self.world.reset()\n\n        # Set camera view\n        set_camera_view(eye=[15, 15, 15], target=[0, 0, 0])\n\n        for i in range(steps):\n            self.world.step(render=True)\n\n            # Simple navigation logic (for demonstration)\n            if i % 100 == 0:\n                current_pos = self.get_robot_position()\n                if current_pos is not None:\n                    print(f"Robot position: [{current_pos[0]:.2f}, {current_pos[1]:.2f}, {current_pos[2]:.2f}]")\n\n        print("Navigation environment simulation completed")\n\n# Create and run the navigation environment\nif __name__ == "__main__":\n    nav_env = NavigationEnvironment()\n    nav_env.run_simulation(steps=500)\n'})}),"\n",(0,o.jsx)(e.h3,{id:"step-2-implement-a-path-planning-algorithm",children:"Step 2: Implement A* path planning algorithm"}),"\n",(0,o.jsxs)(e.p,{children:["Create ",(0,o.jsx)(e.code,{children:"~/isaac_sim_examples/path_planning.py"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n# path_planning.py\nimport omni\nfrom omni.isaac.core import World\nfrom omni.isaac.core.utils.prims import create_primitive\nfrom omni.isaac.core.utils.viewports import set_camera_view\nimport numpy as np\nimport heapq\nfrom scipy.spatial.distance import euclidean\nimport carb\n\nclass PathPlanner:\n    def __init__(self, world_size=20, resolution=0.5):\n        self.world_size = world_size\n        self.resolution = resolution\n        self.grid_size = int(world_size / resolution)\n        self.grid = np.zeros((self.grid_size, self.grid_size))\n\n        # Initialize the world for path planning\n        self.world = World(stage_units_in_meters=1.0)\n        self.setup_environment()\n\n    def setup_environment(self):\n        """Set up environment with obstacles for path planning."""\n        # Create ground plane\n        create_primitive(\n            prim_path="/World/GroundPlane",\n            primitive_type="Plane",\n            scale=[self.world_size, self.world_size, 1],\n            position=[0, 0, 0]\n        )\n\n        # Create obstacles (these will be marked in the grid)\n        obstacle_positions = [\n            [5, 5], [5, 6], [5, 7],  # Column obstacle\n            [-5, -5], [-5, -6], [-5, -7],  # Column obstacle\n            [2, 2], [2, -2], [-2, 2], [-2, -2],  # Square obstacles\n            [0, 5], [1, 5], [-1, 5], [0, 6],  # Central obstacle\n        ]\n\n        self.obstacles = []\n        for i, pos in enumerate(obstacle_positions):\n            obstacle = create_primitive(\n                prim_path=f"/World/Obstacle_{i}",\n                primitive_type="Cylinder",\n                scale=[0.4, 0.4, 1.0],\n                position=[pos[0], pos[1], 0.5],\n                color=[0.8, 0.2, 0.2]\n            )\n            self.obstacles.append(obstacle)\n\n            # Mark obstacle in grid\n            grid_x = int((pos[0] + self.world_size/2) / self.resolution)\n            grid_y = int((pos[1] + self.world_size/2) / self.resolution)\n\n            if 0 <= grid_x < self.grid_size and 0 <= grid_y < self.grid_size:\n                self.grid[grid_y, grid_x] = 1  # Occupied\n\n        # Create start and goal markers\n        self.start_marker = create_primitive(\n            prim_path="/World/Start",\n            primitive_type="Sphere",\n            scale=[0.3, 0.3, 0.3],\n            position=[-8, -8, 0.15],\n            color=[0, 1, 0]\n        )\n\n        self.goal_marker = create_primitive(\n            prim_path="/World/Goal",\n            primitive_type="Sphere",\n            scale=[0.3, 0.3, 0.3],\n            position=[8, 8, 0.15],\n            color=[1, 0, 0]\n        )\n\n    def world_to_grid(self, x, y):\n        """Convert world coordinates to grid coordinates."""\n        grid_x = int((x + self.world_size/2) / self.resolution)\n        grid_y = int((y + self.world_size/2) / self.resolution)\n        return grid_x, grid_y\n\n    def grid_to_world(self, grid_x, grid_y):\n        """Convert grid coordinates to world coordinates."""\n        x = grid_x * self.resolution - self.world_size/2 + self.resolution/2\n        y = grid_y * self.resolution - self.world_size/2 + self.resolution/2\n        return x, y\n\n    def get_neighbors(self, pos):\n        """Get valid neighboring cells."""\n        x, y = pos\n        neighbors = []\n\n        # 8-directional movement (including diagonals)\n        directions = [\n            (-1, -1), (-1, 0), (-1, 1),\n            (0, -1),           (0, 1),\n            (1, -1),  (1, 0),  (1, 1)\n        ]\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n\n            # Check bounds\n            if 0 <= nx < self.grid_size and 0 <= ny < self.grid_size:\n                # Check if not occupied\n                if self.grid[ny, nx] == 0:\n                    neighbors.append((nx, ny))\n\n        return neighbors\n\n    def heuristic(self, a, b):\n        """Heuristic function for A* (Euclidean distance)."""\n        return euclidean(a, b)\n\n    def a_star(self, start, goal):\n        """A* pathfinding algorithm."""\n        start = self.world_to_grid(start[0], start[1])\n        goal = self.world_to_grid(goal[0], goal[1])\n\n        # Convert to grid coordinates\n        if start[0] < 0 or start[0] >= self.grid_size or start[1] < 0 or start[1] >= self.grid_size:\n            print("Start position outside grid")\n            return None\n\n        if goal[0] < 0 or goal[0] >= self.grid_size or goal[1] < 0 or goal[1] >= self.grid_size:\n            print("Goal position outside grid")\n            return None\n\n        if self.grid[start[1], start[0]] == 1:\n            print("Start position is occupied")\n            return None\n\n        if self.grid[goal[1], goal[0]] == 1:\n            print("Goal position is occupied")\n            return None\n\n        # Initialize A*\n        frontier = [(0, start)]\n        came_from = {}\n        cost_so_far = {start: 0}\n        priority = {start: 0}\n\n        while frontier:\n            current = heapq.heappop(frontier)[1]\n\n            if current == goal:\n                break\n\n            for next_pos in self.get_neighbors(current):\n                new_cost = cost_so_far[current] + euclidean(current, next_pos)\n\n                if next_pos not in cost_so_far or new_cost < cost_so_far[next_pos]:\n                    cost_so_far[next_pos] = new_cost\n                    priority = new_cost + self.heuristic(next_pos, goal)\n                    heapq.heappush(frontier, (priority, next_pos))\n                    came_from[next_pos] = current\n\n        # Reconstruct path\n        if goal not in came_from:\n            return None  # No path found\n\n        path = []\n        current = goal\n        while current != start:\n            path.append(current)\n            current = came_from[current]\n        path.append(start)\n        path.reverse()\n\n        # Convert path back to world coordinates\n        world_path = []\n        for grid_pos in path:\n            world_x, world_y = self.grid_to_world(grid_pos[0], grid_pos[1])\n            world_path.append([world_x, world_y, 0.5])  # Add height\n\n        return world_path\n\n    def visualize_path(self, path):\n        """Create visualization of the path."""\n        if path is None:\n            print("No path to visualize")\n            return\n\n        # Create path markers\n        for i, pos in enumerate(path):\n            create_primitive(\n                prim_path=f"/World/PathMarker_{i}",\n                primitive_type="Sphere",\n                scale=[0.1, 0.1, 0.1],\n                position=[pos[0], pos[1], pos[2]],\n                color=[0, 0, 1]  # Blue path markers\n            )\n\n    def run_path_planning(self):\n        """Run path planning demonstration."""\n        self.world.reset()\n\n        # Set camera view\n        set_camera_view(eye=[15, 15, 15], target=[0, 0, 0])\n\n        # Plan path\n        start_pos = [-8, -8, 0.5]\n        goal_pos = [8, 8, 0.5]\n\n        print(f"Planning path from {start_pos[:2]} to {goal_pos[:2]}")\n        path = self.a_star(start_pos, goal_pos)\n\n        if path:\n            print(f"Found path with {len(path)} waypoints")\n            self.visualize_path(path)\n        else:\n            print("No path found")\n\n        # Run simulation briefly to show results\n        for i in range(200):\n            self.world.step(render=True)\n\n        print("Path planning demonstration completed")\n\n# Create and run the path planner\nif __name__ == "__main__":\n    planner = PathPlanner()\n    planner.run_path_planning()\n'})}),"\n",(0,o.jsx)(e.h2,{id:"exercise-2-motion-control-systems",children:"Exercise 2: Motion Control Systems"}),"\n",(0,o.jsx)(e.h3,{id:"step-1-create-a-motion-control-system",children:"Step 1: Create a motion control system"}),"\n",(0,o.jsxs)(e.p,{children:["Create ",(0,o.jsx)(e.code,{children:"~/isaac_sim_examples/motion_control.py"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n# motion_control.py\nimport omni\nfrom omni.isaac.core import World\nfrom omni.isaac.core.utils.prims import create_primitive\nfrom omni.isaac.core.utils.viewports import set_camera_view\nfrom omni.isaac.core.controllers import BaseController\nfrom omni.isaac.core.articulations import Articulation\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\nfrom omni.isaac.core.utils.nucleus import get_assets_root_path\nimport numpy as np\nimport carb\nfrom scipy.spatial.transform import Rotation as R\n\nclass DifferentialDriveController(BaseController):\n    """Simple differential drive controller for wheeled robot."""\n\n    def __init__(\n        self,\n        name: str = "diff_drive_controller",\n        wheel_radius: float = 0.1,\n        wheel_base: float = 0.4\n    ) -> None:\n        super().__init__(name=name)\n        self.wheel_radius = wheel_radius\n        self.wheel_base = wheel_base\n\n        # Control parameters\n        self.linear_velocity = 0.0\n        self.angular_velocity = 0.0\n\n        # PID controller parameters\n        self.kp = 1.0\n        self.ki = 0.1\n        self.kd = 0.05\n\n        # For PID control\n        self.prev_error = 0.0\n        self.integral = 0.0\n\n    def forward(\n        self,\n        current_joint_positions,\n        current_joint_velocities,\n        target_positions,\n        target_velocities,\n        dt\n    ):\n        """Calculate joint commands based on target velocities."""\n        # Convert linear/angular velocities to wheel velocities\n        left_wheel_vel = (self.linear_velocity - self.angular_velocity * self.wheel_base / 2) / self.wheel_radius\n        right_wheel_vel = (self.linear_velocity + self.angular_velocity * self.wheel_base / 2) / self.wheel_radius\n\n        # Return joint position and velocity commands\n        return {\n            "position": target_positions,\n            "velocity": [left_wheel_vel, right_wheel_vel]\n        }\n\nclass MotionControlSystem:\n    def __init__(self):\n        self.world = World(stage_units_in_meters=1.0)\n        self.robot = None\n        self.controller = None\n        self.setup_environment()\n\n    def setup_environment(self):\n        """Set up environment for motion control."""\n        # Create ground plane\n        create_primitive(\n            prim_path="/World/GroundPlane",\n            primitive_type="Plane",\n            scale=[20, 20, 1],\n            position=[0, 0, 0]\n        )\n\n        # Create a simple wheeled robot\n        self.robot = create_primitive(\n            prim_path="/World/Robot",\n            primitive_type="Cylinder",\n            scale=[0.5, 0.5, 0.8],\n            position=[0, 0, 0.4],\n            color=[0.2, 0.6, 1.0]\n        )\n\n        # Create wheels\n        self.left_wheel = create_primitive(\n            prim_path="/World/Robot/LeftWheel",\n            primitive_type="Cylinder",\n            scale=[0.15, 0.15, 0.05],\n            position=[0.2, 0.25, 0.1],\n            color=[0.3, 0.3, 0.3]\n        )\n\n        self.right_wheel = create_primitive(\n            prim_path="/World/Robot/RightWheel",\n            primitive_type="Cylinder",\n            scale=[0.15, 0.15, 0.05],\n            position=[0.2, -0.25, 0.1],\n            color=[0.3, 0.3, 0.3]\n        )\n\n        # Create reference frames for navigation\n        for i in range(10):\n            create_primitive(\n                prim_path=f"/World/Reference_{i}",\n                primitive_type="Cylinder",\n                scale=[0.2, 0.2, 0.5],\n                position=[np.random.uniform(-8, 8), np.random.uniform(-8, 8), 0.25],\n                color=[1, 0.5, 0]\n            )\n\n        # Create controller\n        self.controller = DifferentialDriveController(\n            name="diff_drive_controller",\n            wheel_radius=0.1,\n            wheel_base=0.5\n        )\n\n    def simple_navigation(self):\n        """Implement simple navigation behavior."""\n        # Get robot position\n        robot_pos = self.get_robot_position()\n        if robot_pos is None:\n            return [0, 0]  # Stop if no position\n\n        # Define a simple navigation pattern (square path)\n        target_points = [\n            [5, 0, 0.4],\n            [5, 5, 0.4],\n            [0, 5, 0.4],\n            [0, 0, 0.4]\n        ]\n\n        # Determine current target based on time\n        current_target_idx = int(self.world.current_time_step_index / 300) % len(target_points)\n        target = target_points[current_target_idx]\n\n        # Calculate desired velocity toward target\n        direction = np.array(target[:2]) - robot_pos[:2]\n        distance = np.linalg.norm(direction)\n\n        if distance > 0.5:  # If not close to target\n            # Normalize direction\n            direction = direction / distance\n\n            # Calculate linear and angular velocities\n            linear_vel = min(distance * 0.5, 1.0)  # Scale with distance, max 1 m/s\n            angular_vel = np.arctan2(direction[1], direction[0]) * 0.5  # Turn toward target\n\n            return [linear_vel, angular_vel]\n        else:\n            # Close to target, slow down\n            return [0.2, 0.0]\n\n    def get_robot_position(self):\n        """Get current robot position."""\n        if self.robot:\n            from pxr import UsdGeom\n            stage = omni.usd.get_context().get_stage()\n            prim = stage.GetPrimAtPath("/World/Robot")\n            xform = UsdGeom.Xformable(prim)\n            transform = xform.ComputeLocalToWorldTransform(omni.usd.get_context().get_time_code())\n            pos = transform.ExtractTranslation()\n            return np.array([pos[0], pos[1], pos[2]])\n        return None\n\n    def run_motion_control(self, steps=1500):\n        """Run motion control simulation."""\n        self.world.reset()\n\n        # Set camera view\n        set_camera_view(eye=[10, 10, 10], target=[0, 0, 0])\n\n        for i in range(steps):\n            self.world.step(render=True)\n\n            # Calculate navigation commands every 10 steps\n            if i % 10 == 0:\n                commands = self.simple_navigation()\n\n                # Apply commands to controller\n                self.controller.linear_velocity = commands[0]\n                self.controller.angular_velocity = commands[1]\n\n                # Print status\n                pos = self.get_robot_position()\n                if pos is not None:\n                    print(f"Step {i}: Pos=({pos[0]:.2f}, {pos[1]:.2f}), Cmds=({commands[0]:.2f}, {commands[1]:.2f})")\n\n        print("Motion control simulation completed")\n\n# Create and run the motion control system\nif __name__ == "__main__":\n    motion_ctrl = MotionControlSystem()\n    motion_ctrl.run_motion_control(steps=1000)\n'})}),"\n",(0,o.jsx)(e.h2,{id:"exercise-3-advanced-control-systems",children:"Exercise 3: Advanced Control Systems"}),"\n",(0,o.jsx)(e.h3,{id:"step-1-implement-pid-controller-with-feedback",children:"Step 1: Implement PID controller with feedback"}),"\n",(0,o.jsxs)(e.p,{children:["Create ",(0,o.jsx)(e.code,{children:"~/isaac_sim_examples/pid_control.py"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\n# pid_control.py\nimport omni\nfrom omni.isaac.core import World\nfrom omni.isaac.core.utils.prims import create_primitive\nfrom omni.isaac.core.utils.viewports import set_camera_view\nimport numpy as np\nimport carb\n\nclass PIDController:\n    \"\"\"PID controller implementation.\"\"\"\n\n    def __init__(self, kp=1.0, ki=0.1, kd=0.05, setpoint=0.0):\n        self.kp = kp\n        self.ki = ki\n        self.kd = kd\n        self.setpoint = setpoint\n\n        self.previous_error = 0.0\n        self.integral = 0.0\n        self.derivative = 0.0\n\n    def compute(self, current_value, dt=0.01):\n        \"\"\"Compute control output.\"\"\"\n        error = self.setpoint - current_value\n\n        # Proportional term\n        p_term = self.kp * error\n\n        # Integral term\n        self.integral += error * dt\n        i_term = self.ki * self.integral\n\n        # Derivative term\n        if dt > 0:\n            self.derivative = (error - self.previous_error) / dt\n        d_term = self.kd * self.derivative\n\n        # Store error for next iteration\n        self.previous_error = error\n\n        # Calculate output\n        output = p_term + i_term + d_term\n\n        return output\n\nclass AdvancedControlSystem:\n    def __init__(self):\n        self.world = World(stage_units_in_meters=1.0)\n        self.robots = []\n        self.controllers = []\n        self.setup_environment()\n\n    def setup_environment(self):\n        \"\"\"Set up environment with multiple robots for control testing.\"\"\"\n        # Create ground plane\n        create_primitive(\n            prim_path=\"/World/GroundPlane\",\n            primitive_type=\"Plane\",\n            scale=[30, 30, 1],\n            position=[0, 0, 0]\n        )\n\n        # Create multiple robots with different control tasks\n        robot_configs = [\n            {'name': 'Robot1', 'start_pos': [-8, -8, 0.5], 'target': [8, 8, 0.5]},\n            {'name': 'Robot2', 'start_pos': [8, -8, 0.5], 'target': [-8, 8, 0.5]},\n            {'name': 'Robot3', 'start_pos': [0, 8, 0.5], 'target': [0, -8, 0.5]},\n        ]\n\n        for config in robot_configs:\n            robot = create_primitive(\n                prim_path=f\"/World/{config['name']}\",\n                primitive_type=\"Cylinder\",\n                scale=[0.4, 0.4, 0.8],\n                position=config['start_pos'],\n                color=[0.2, 0.8, 0.2] if '1' in config['name'] else [0.8, 0.2, 0.2] if '2' in config['name'] else [0.2, 0.2, 0.8]\n            )\n            self.robots.append({'robot': robot, 'config': config})\n\n            # Create PID controllers for X and Y positions\n            x_controller = PIDController(kp=2.0, ki=0.1, kd=0.05, setpoint=config['target'][0])\n            y_controller = PIDController(kp=2.0, ki=0.1, kd=0.05, setpoint=config['target'][1])\n            self.controllers.append({'x': x_controller, 'y': y_controller, 'robot': robot})\n\n        # Create obstacles\n        for i in range(15):\n            create_primitive(\n                prim_path=f\"/World/Obstacle_{i}\",\n                primitive_type=\"Cylinder\",\n                scale=[0.3, 0.3, 1.0],\n                position=[np.random.uniform(-10, 10), np.random.uniform(-10, 10), 0.5],\n                color=[0.5, 0.5, 0.5]\n            )\n\n        # Create target markers\n        for i, config in enumerate(robot_configs):\n            create_primitive(\n                prim_path=f\"/World/Target_{i}\",\n                primitive_type=\"Sphere\",\n                scale=[0.3, 0.3, 0.3],\n                position=config['target'],\n                color=[1, 1, 0]  # Yellow targets\n            )\n\n    def get_robot_position(self, robot_prim):\n        \"\"\"Get robot position.\"\"\"\n        if robot_prim:\n            from pxr import UsdGeom\n            stage = omni.usd.get_context().get_stage()\n            prim = stage.GetPrimAtPath(str(robot_prim.GetPrimPath()))\n            xform = UsdGeom.Xformable(prim)\n            transform = xform.ComputeLocalToWorldTransform(omni.usd.get_context().get_time_code())\n            pos = transform.ExtractTranslation()\n            return np.array([pos[0], pos[1], pos[2]])\n        return None\n\n    def update_robot_position(self, robot_prim, new_pos):\n        \"\"\"Update robot position.\"\"\"\n        if robot_prim:\n            from pxr import Gf, UsdGeom\n            stage = omni.usd.get_context().get_stage()\n            prim_path = str(robot_prim.GetPrimPath())\n            prim = stage.GetPrimAtPath(prim_path)\n            xform = UsdGeom.Xformable(prim)\n\n            # Get current transform and update position\n            transform = xform.GetLocalTransformation()\n            transform.SetTranslate(Gf.Vec3d(new_pos[0], new_pos[1], new_pos[2]))\n            xform.SetLocalTransformation(transform)\n\n    def run_pid_control(self, steps=2000):\n        \"\"\"Run PID control simulation.\"\"\"\n        self.world.reset()\n\n        # Set camera view\n        set_camera_view(eye=[20, 20, 20], target=[0, 0, 0])\n\n        for i in range(steps):\n            self.world.step(render=True)\n\n            # Update robot positions using PID control every 5 steps\n            if i % 5 == 0:\n                dt = 0.005  # Assuming 200Hz control rate\n\n                for j, (robot_info, controller_info) in enumerate(zip(self.robots, self.controllers)):\n                    current_pos = self.get_robot_position(robot_info['robot'])\n\n                    if current_pos is not None:\n                        # Get current position\n                        current_x, current_y, current_z = current_pos\n\n                        # Update PID setpoints\n                        target_x = robot_info['config']['target'][0]\n                        target_y = robot_info['config']['target'][1]\n\n                        controller_info['x'].setpoint = target_x\n                        controller_info['y'].setpoint = target_y\n\n                        # Compute control outputs\n                        x_output = controller_info['x'].compute(current_x, dt)\n                        y_output = controller_info['y'].compute(current_y, dt)\n\n                        # Calculate new position (simple integration)\n                        new_x = current_x + x_output * dt\n                        new_y = current_y + y_output * dt\n                        new_z = current_z\n\n                        # Apply position update\n                        self.update_robot_position(robot_info['robot'], [new_x, new_y, new_z])\n\n                        # Print status every 100 steps\n                        if i % 100 == 0:\n                            distance_to_target = np.sqrt((new_x - target_x)**2 + (new_y - target_y)**2)\n                            print(f\"Robot {j+1}: Pos=({new_x:.2f}, {new_y:.2f}), \"\n                                  f\"Target=({target_x:.2f}, {target_y:.2f}), \"\n                                  f\"Distance={distance_to_target:.2f}m\")\n\n        print(\"PID control simulation completed\")\n\n# Create and run the advanced control system\nif __name__ == \"__main__\":\n    advanced_ctrl = AdvancedControlSystem()\n    advanced_ctrl.run_pid_control(steps=1500)\n"})}),"\n",(0,o.jsx)(e.h2,{id:"exercise-4-ros-integration-for-planning-and-control",children:"Exercise 4: ROS Integration for Planning and Control"}),"\n",(0,o.jsx)(e.h3,{id:"step-1-create-ros-navigation-integration",children:"Step 1: Create ROS navigation integration"}),"\n",(0,o.jsxs)(e.p,{children:["Create ",(0,o.jsx)(e.code,{children:"~/isaac_sim_examples/ros_navigation.py"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n# ros_navigation.py\nimport omni\nfrom omni.isaac.core import World\nfrom omni.isaac.core.utils.prims import create_primitive\nfrom omni.isaac.core.utils.viewports import set_camera_view\nfrom omni.isaac.sensor import Camera\nimport omni.isaac.ros2_bridge._ros2_bridge as ros2_bridge\nimport numpy as np\nimport carb\n\nclass ROSNavigationSystem:\n    def __init__(self):\n        self.world = World(stage_units_in_meters=1.0)\n        self.ros2_bridge = ros2_bridge.acquire_ros2_bridge_interface()\n        self.robots = []\n        self.setup_environment()\n\n    def setup_environment(self):\n        """Set up environment for ROS navigation testing."""\n        # Create ground plane\n        create_primitive(\n            prim_path="/World/GroundPlane",\n            primitive_type="Plane",\n            scale=[25, 25, 1],\n            position=[0, 0, 0]\n        )\n\n        # Create a navigation map-like environment\n        # Create walls to form rooms and corridors\n        wall_thickness = 0.3\n        wall_height = 2.0\n\n        # Create room walls\n        room_centers = [[-6, -6], [6, -6], [-6, 6], [6, 6]]\n        for center in room_centers:\n            # Room walls\n            create_primitive(\n                prim_path=f"/World/RoomWall_Horizontal1_{center[0]}_{center[1]}",\n                primitive_type="Cuboid",\n                scale=[6, wall_thickness, wall_height],\n                position=[center[0], center[1] + 3, wall_height/2]\n            )\n            create_primitive(\n                prim_path=f"/World/RoomWall_Horizontal2_{center[0]}_{center[1]}",\n                primitive_type="Cuboid",\n                scale=[6, wall_thickness, wall_height],\n                position=[center[0], center[1] - 3, wall_height/2]\n            )\n            create_primitive(\n                prim_path=f"/World/RoomWall_Vertical1_{center[0]}_{center[1]}",\n                primitive_type="Cuboid",\n                scale=[wall_thickness, 6, wall_height],\n                position=[center[0] + 3, center[1], wall_height/2]\n            )\n            create_primitive(\n                prim_path=f"/World/RoomWall_Vertical2_{center[0]}_{center[1]}",\n                primitive_type="Cuboid",\n                scale=[wall_thickness, 6, wall_height],\n                position=[center[0] - 3, center[1], wall_height/2]\n            )\n\n        # Create robot with sensors\n        robot = create_primitive(\n            prim_path="/World/Robot",\n            primitive_type="Cylinder",\n            scale=[0.5, 0.5, 1.0],\n            position=[-8, -8, 0.5],\n            color=[0.2, 0.6, 1.0]\n        )\n        self.robots.append(robot)\n\n        # Add camera for perception\n        camera = Camera(\n            prim_path="/World/Robot/Camera",\n            frequency=30,\n            resolution=(640, 480),\n            position=[0.3, 0, 0.5]\n        )\n        camera.set_local_pose(translation=np.array([0.3, 0, 0.5]))\n\n        # Add LiDAR for navigation\n        from omni.isaac.range_sensor import LidarRtx\n        lidar = LidarRtx(\n            prim_path="/World/Robot/Lidar",\n            translation=(0.0, 0.0, 0.8),\n            config="Example_Rotary",\n            range_resolution=0.005,\n            rotation_frequency=10,\n            horizontal_resolution=0.25,\n            vertical_resolution=0.4,\n            horizontal_samples=1080,\n            vertical_samples=64,\n            max_range=25.0,\n            min_range=0.1\n        )\n\n        # Enable ROS bridge for navigation\n        self.enable_ros_bridge(camera, lidar)\n\n    def enable_ros_bridge(self, camera, lidar):\n        """Enable ROS bridge for navigation sensors."""\n        # Publish camera data\n        self.ros2_bridge.publish_camera(\n            camera,\n            topic_name="/humanoid/camera/image_raw",\n            sensor_name="camera"\n        )\n\n        # Publish LiDAR data\n        self.ros2_bridge.publish_lidar(\n            lidar,\n            topic_name="/humanoid/scan",\n            sensor_name="lidar"\n        )\n\n        # Publish TF transforms\n        self.ros2_bridge.publish_transform_tree(\n            prim_path="/World",\n            topic_name="/tf"\n        )\n\n        # Publish robot state\n        self.ros2_bridge.publish_robot_state(\n            prim_path="/World/Robot",\n            topic_name="/joint_states"\n        )\n\n    def run_ros_navigation(self, steps=1000):\n        """Run ROS navigation simulation."""\n        self.world.reset()\n\n        # Set camera view\n        set_camera_view(eye=[20, 20, 20], target=[0, 0, 0])\n\n        for i in range(steps):\n            self.world.step(render=True)\n\n            # Print status every 100 steps\n            if i % 100 == 0:\n                print(f"ROS Navigation simulation step: {i}/{steps}")\n\n        print("ROS navigation simulation completed")\n\n# Create and run the ROS navigation system\nif __name__ == "__main__":\n    ros_nav = ROSNavigationSystem()\n    ros_nav.run_ros_navigation(steps=800)\n'})}),"\n",(0,o.jsx)(e.h2,{id:"exercise-5-behavior-trees-for-complex-navigation",children:"Exercise 5: Behavior Trees for Complex Navigation"}),"\n",(0,o.jsx)(e.h3,{id:"step-1-implement-a-behavior-tree-system",children:"Step 1: Implement a behavior tree system"}),"\n",(0,o.jsxs)(e.p,{children:["Create ",(0,o.jsx)(e.code,{children:"~/isaac_sim_examples/behavior_trees.py"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n# behavior_trees.py\nimport omni\nfrom omni.isaac.core import World\nfrom omni.isaac.core.utils.prims import create_primitive\nfrom omni.isaac.core.utils.viewports import set_camera_view\nimport numpy as np\nimport carb\n\nclass BehaviorNode:\n    """Base class for behavior tree nodes."""\n\n    def __init__(self, name):\n        self.name = name\n        self.status = "IDLE"\n\n    def tick(self, blackboard):\n        """Execute the behavior. Return \'SUCCESS\', \'FAILURE\', or \'RUNNING\'."""\n        raise NotImplementedError\n\nclass SelectorNode(BehaviorNode):\n    """Selector node - returns SUCCESS if any child succeeds."""\n\n    def __init__(self, name, children):\n        super().__init__(name)\n        self.children = children\n\n    def tick(self, blackboard):\n        for child in self.children:\n            status = child.tick(blackboard)\n            if status == "SUCCESS":\n                return "SUCCESS"\n            elif status == "RUNNING":\n                return "RUNNING"\n        return "FAILURE"\n\nclass SequenceNode(BehaviorNode):\n    """Sequence node - returns FAILURE if any child fails."""\n\n    def __init__(self, name, children):\n        super().__init__(name)\n        self.children = children\n\n    def tick(self, blackboard):\n        for child in self.children:\n            status = child.tick(blackboard)\n            if status == "FAILURE":\n                return "FAILURE"\n            elif status == "RUNNING":\n                return "RUNNING"\n        return "SUCCESS"\n\nclass ConditionNode(BehaviorNode):\n    """Condition node - checks a condition."""\n\n    def __init__(self, name, condition_func):\n        super().__init__(name)\n        self.condition_func = condition_func\n\n    def tick(self, blackboard):\n        if self.condition_func(blackboard):\n            return "SUCCESS"\n        else:\n            return "FAILURE"\n\nclass ActionNode(BehaviorNode):\n    """Action node - performs an action."""\n\n    def __init__(self, name, action_func):\n        super().__init__(name)\n        self.action_func = action_func\n\n    def tick(self, blackboard):\n        return self.action_func(blackboard)\n\nclass NavigationBehaviorTree:\n    def __init__(self):\n        self.world = World(stage_units_in_meters=1.0)\n        self.blackboard = {\n            \'robot_position\': np.array([0, 0, 0.5]),\n            \'goal_position\': np.array([8, 8, 0.5]),\n            \'obstacles\': [],\n            \'current_waypoint\': None,\n            \'navigation_status\': \'IDLE\'\n        }\n        self.behavior_tree = self.create_behavior_tree()\n        self.setup_environment()\n\n    def setup_environment(self):\n        """Set up environment for behavior tree testing."""\n        # Create ground plane\n        create_primitive(\n            prim_path="/World/GroundPlane",\n            primitive_type="Plane",\n            scale=[20, 20, 1],\n            position=[0, 0, 0]\n        )\n\n        # Create robot\n        self.robot = create_primitive(\n            prim_path="/World/Robot",\n            primitive_type="Cylinder",\n            scale=[0.5, 0.5, 1.0],\n            position=[0, 0, 0.5],\n            color=[0.2, 0.6, 1.0]\n        )\n\n        # Create goal\n        create_primitive(\n            prim_path="/World/Goal",\n            primitive_type="Sphere",\n            scale=[0.3, 0.3, 0.3],\n            position=[8, 8, 0.15],\n            color=[1, 0, 0]\n        )\n\n        # Create obstacles\n        for i in range(8):\n            create_primitive(\n                prim_path=f"/World/Obstacle_{i}",\n                primitive_type="Cylinder",\n                scale=[0.4, 0.4, 1.0],\n                position=[np.random.uniform(-6, 6), np.random.uniform(-6, 6), 0.5],\n                color=[0.8, 0.2, 0.2]\n            )\n\n        # Update blackboard with initial positions\n        self.blackboard[\'robot_position\'] = np.array([0, 0, 0.5])\n        self.blackboard[\'goal_position\'] = np.array([8, 8, 0.5])\n\n    def create_behavior_tree(self):\n        """Create navigation behavior tree."""\n        # Define conditions\n        def is_at_goal(blackboard):\n            robot_pos = blackboard[\'robot_position\']\n            goal_pos = blackboard[\'goal_position\']\n            distance = np.linalg.norm(robot_pos[:2] - goal_pos[:2])\n            return distance < 0.5\n\n        def is_path_clear(blackboard):\n            # Simplified path clearance check\n            return True  # In a real implementation, this would check for obstacles\n\n        def has_battery_power(blackboard):\n            # Simulate battery level\n            return blackboard.get(\'battery_level\', 100) > 10\n\n        # Define actions\n        def plan_path(blackboard):\n            # In a real implementation, this would call path planning\n            print("Planning path to goal...")\n            blackboard[\'current_waypoint\'] = blackboard[\'goal_position\']\n            return "SUCCESS"\n\n        def move_to_waypoint(blackboard):\n            # Move robot towards waypoint\n            if blackboard[\'current_waypoint\'] is not None:\n                robot_pos = blackboard[\'robot_position\']\n                waypoint = blackboard[\'current_waypoint\']\n\n                # Simple movement toward waypoint\n                direction = waypoint[:2] - robot_pos[:2]\n                distance = np.linalg.norm(direction)\n\n                if distance > 0.1:\n                    # Move robot\n                    move_step = direction / distance * 0.1  # 10cm step\n                    new_pos = robot_pos.copy()\n                    new_pos[0] += move_step[0]\n                    new_pos[1] += move_step[1]\n\n                    # Update robot position in Isaac Sim\n                    self.update_robot_position(new_pos)\n                    blackboard[\'robot_position\'] = new_pos\n\n                    print(f"Moving to waypoint: ({waypoint[0]:.2f}, {waypoint[1]:.2f})")\n                    return "RUNNING"\n                else:\n                    print("Reached waypoint!")\n                    return "SUCCESS"\n            return "FAILURE"\n\n        def recharge_battery(blackboard):\n            print("Recharging battery...")\n            blackboard[\'battery_level\'] = 100\n            return "SUCCESS"\n\n        # Create behavior tree nodes\n        # Root: Selector that tries navigation or recharging\n        root = SelectorNode("Root", [\n            # Sequence: Check battery and navigate\n            SequenceNode("Navigate", [\n                ConditionNode("Has Battery Power", has_battery_power),\n                ConditionNode("Not At Goal", lambda bb: not is_at_goal(bb)),\n                ActionNode("Plan Path", plan_path),\n                ActionNode("Move to Waypoint", move_to_waypoint)\n            ]),\n            # If navigation fails due to low battery, recharge\n            SequenceNode("Recharge", [\n                ConditionNode("Needs Charging", lambda bb: bb.get(\'battery_level\', 100) <= 10),\n                ActionNode("Recharge Battery", recharge_battery)\n            ])\n        ])\n\n        return root\n\n    def update_robot_position(self, new_pos):\n        """Update robot position in Isaac Sim."""\n        if self.robot:\n            from pxr import Gf, UsdGeom\n            stage = omni.usd.get_context().get_stage()\n            prim = stage.GetPrimAtPath("/World/Robot")\n            xform = UsdGeom.Xformable(prim)\n\n            transform = xform.GetLocalTransformation()\n            transform.SetTranslate(Gf.Vec3d(new_pos[0], new_pos[1], new_pos[2]))\n            xform.SetLocalTransformation(transform)\n\n    def run_behavior_tree(self, steps=1000):\n        """Run behavior tree simulation."""\n        self.world.reset()\n\n        # Set camera view\n        set_camera_view(eye=[15, 15, 15], target=[0, 0, 0])\n\n        for i in range(steps):\n            self.world.step(render=True)\n\n            # Execute behavior tree every 10 steps\n            if i % 10 == 0:\n                status = self.behavior_tree.tick(self.blackboard)\n\n                # Print status\n                robot_pos = self.blackboard[\'robot_position\']\n                goal_pos = self.blackboard[\'goal_position\']\n                distance = np.linalg.norm(robot_pos[:2] - goal_pos[:2])\n\n                print(f"Step {i}: BT Status=\'{status}\', Distance to goal={distance:.2f}m")\n\n                # Check if goal reached\n                if distance < 0.5:\n                    print("GOAL REACHED!")\n                    break\n\n        print("Behavior tree navigation simulation completed")\n\n# Create and run the behavior tree navigation system\nif __name__ == "__main__":\n    behavior_nav = NavigationBehaviorTree()\n    behavior_nav.run_behavior_tree(steps=1000)\n'})}),"\n",(0,o.jsx)(e.h2,{id:"exercise-6-control-system-validation-and-testing",children:"Exercise 6: Control System Validation and Testing"}),"\n",(0,o.jsx)(e.h3,{id:"step-1-create-control-validation-tools",children:"Step 1: Create control validation tools"}),"\n",(0,o.jsxs)(e.p,{children:["Create ",(0,o.jsx)(e.code,{children:"~/isaac_sim_examples/control_validation.py"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\n# control_validation.py\nimport omni\nfrom omni.isaac.core import World\nfrom omni.isaac.core.utils.prims import create_primitive\nfrom omni.isaac.core.utils.viewports import set_camera_view\nimport numpy as np\nimport carb\n\nclass ControlValidationSystem:\n    def __init__(self):\n        self.world = World(stage_units_in_meters=1.0)\n        self.robots = []\n        self.validation_metrics = {}\n        self.setup_environment()\n\n    def setup_environment(self):\n        \"\"\"Set up environment for control validation.\"\"\"\n        # Create ground plane\n        create_primitive(\n            prim_path=\"/World/GroundPlane\",\n            primitive_type=\"Plane\",\n            scale=[30, 30, 1],\n            position=[0, 0, 0]\n        )\n\n        # Create test trajectories for validation\n        test_configs = [\n            {'name': 'Circle', 'type': 'circular', 'center': [0, 0], 'radius': 5},\n            {'name': 'Square', 'type': 'square', 'center': [8, 0], 'size': 4},\n            {'name': 'Figure8', 'type': 'figure8', 'center': [-8, 0], 'scale': 3},\n        ]\n\n        for i, config in enumerate(test_configs):\n            robot = create_primitive(\n                prim_path=f\"/World/ValidationRobot_{i}\",\n                primitive_type=\"Cylinder\",\n                scale=[0.4, 0.4, 0.8],\n                position=self.get_start_position(config),\n                color=[0.8, 0.2, 0.8] if i == 0 else [0.2, 0.8, 0.8] if i == 1 else [0.8, 0.8, 0.2]\n            )\n            self.robots.append({'robot': robot, 'config': config, 'trajectory_idx': 0})\n\n        # Create trajectory markers for visualization\n        for i, config in enumerate(test_configs):\n            trajectory = self.generate_trajectory(config)\n            for j, pos in enumerate(trajectory):\n                if j % 10 == 0:  # Show every 10th point\n                    create_primitive(\n                        prim_path=f\"/World/TrajMarker_{i}_{j}\",\n                        primitive_type=\"Sphere\",\n                        scale=[0.05, 0.05, 0.05],\n                        position=[pos[0], pos[1], 0.1],\n                        color=[1, 1, 0] if i == 0 else [0, 1, 1] if i == 1 else [1, 0, 1]\n                    )\n\n    def get_start_position(self, config):\n        \"\"\"Get start position for trajectory.\"\"\"\n        if config['type'] == 'circular':\n            return [config['center'][0] + config['radius'], config['center'][1], 0.4]\n        elif config['type'] == 'square':\n            return [config['center'][0] - config['size']/2, config['center'][1] - config['size']/2, 0.4]\n        elif config['type'] == 'figure8':\n            return [config['center'][0], config['center'][1], 0.4]\n        return [0, 0, 0.4]\n\n    def generate_trajectory(self, config, num_points=100):\n        \"\"\"Generate test trajectory.\"\"\"\n        trajectory = []\n\n        if config['type'] == 'circular':\n            center = config['center']\n            radius = config['radius']\n            for i in range(num_points):\n                angle = 2 * np.pi * i / num_points\n                x = center[0] + radius * np.cos(angle)\n                y = center[1] + radius * np.sin(angle)\n                trajectory.append([x, y, 0.4])\n\n        elif config['type'] == 'square':\n            center = config['center']\n            size = config['size']\n            half_size = size / 2\n            side_length = num_points // 4\n\n            # Bottom side\n            for i in range(side_length):\n                x = center[0] - half_size + (2 * half_size * i / side_length)\n                y = center[1] - half_size\n                trajectory.append([x, y, 0.4])\n\n            # Right side\n            for i in range(side_length):\n                x = center[0] + half_size\n                y = center[1] - half_size + (2 * half_size * i / side_length)\n                trajectory.append([x, y, 0.4])\n\n            # Top side\n            for i in range(side_length):\n                x = center[0] + half_size - (2 * half_size * i / side_length)\n                y = center[1] + half_size\n                trajectory.append([x, y, 0.4])\n\n            # Left side\n            for i in range(side_length):\n                x = center[0] - half_size\n                y = center[1] + half_size - (2 * half_size * i / side_length)\n                trajectory.append([x, y, 0.4])\n\n        elif config['type'] == 'figure8':\n            center = config['center']\n            scale = config['scale']\n            for i in range(num_points):\n                t = 2 * np.pi * i / num_points\n                x = center[0] + scale * np.sin(t)\n                y = center[1] + scale * np.sin(t) * np.cos(t)\n                trajectory.append([x, y, 0.4])\n\n        return trajectory\n\n    def get_robot_position(self, robot_prim):\n        \"\"\"Get robot position.\"\"\"\n        if robot_prim:\n            from pxr import UsdGeom\n            stage = omni.usd.get_context().get_stage()\n            prim = stage.GetPrimAtPath(str(robot_prim.GetPrimPath()))\n            xform = UsdGeom.Xformable(prim)\n            transform = xform.ComputeLocalToWorldTransform(omni.usd.get_context().get_time_code())\n            pos = transform.ExtractTranslation()\n            return np.array([pos[0], pos[1], pos[2]])\n        return None\n\n    def update_robot_position(self, robot_prim, new_pos):\n        \"\"\"Update robot position.\"\"\"\n        if robot_prim:\n            from pxr import Gf, UsdGeom\n            stage = omni.usd.get_context().get_stage()\n            prim_path = str(robot_prim.GetPrimPath())\n            prim = stage.GetPrimAtPath(prim_path)\n            xform = UsdGeom.Xformable(prim)\n\n            transform = xform.GetLocalTransformation()\n            transform.SetTranslate(Gf.Vec3d(new_pos[0], new_pos[1], new_pos[2]))\n            xform.SetLocalTransformation(transform)\n\n    def calculate_control_metrics(self, robot_info, target_pos):\n        \"\"\"Calculate control performance metrics.\"\"\"\n        current_pos = self.get_robot_position(robot_info['robot'])\n        if current_pos is None:\n            return {}\n\n        # Calculate tracking error\n        error = np.linalg.norm(current_pos[:2] - target_pos[:2])\n\n        # Calculate other metrics\n        metrics = {\n            'tracking_error': error,\n            'distance_to_target': error,\n            'position_accuracy': 1.0 / (1.0 + error) if error > 0 else 1.0,\n            'control_effort': np.linalg.norm([current_pos[0], current_pos[1]])  # Simplified\n        }\n\n        return metrics\n\n    def run_validation_test(self, steps=2000):\n        \"\"\"Run control validation test.\"\"\"\n        self.world.reset()\n\n        # Set camera view\n        set_camera_view(eye=[25, 25, 25], target=[0, 0, 0])\n\n        # Generate trajectories for all robots\n        trajectories = []\n        for robot_info in self.robots:\n            trajectory = self.generate_trajectory(robot_info['config'], num_points=200)\n            trajectories.append(trajectory)\n\n        for i in range(steps):\n            self.world.step(render=True)\n\n            # Update robots following their trajectories\n            for j, (robot_info, trajectory) in enumerate(zip(self.robots, trajectories)):\n                # Get current target in trajectory\n                target_idx = (i // 5) % len(trajectory)  # Update every 5 steps\n                target_pos = trajectory[target_idx]\n\n                # Get current position\n                current_pos = self.get_robot_position(robot_info['robot'])\n\n                if current_pos is not None:\n                    # Simple proportional control to follow trajectory\n                    direction = np.array(target_pos[:2]) - current_pos[:2]\n                    distance = np.linalg.norm(direction)\n\n                    if distance > 0.05:  # Threshold for movement\n                        move_vector = direction / distance * 0.05  # Small step\n                        new_pos = current_pos.copy()\n                        new_pos[0] += move_vector[0]\n                        new_pos[1] += move_vector[1]\n\n                        # Update robot position\n                        self.update_robot_position(robot_info['robot'], new_pos)\n\n                    # Calculate and store metrics\n                    metrics = self.calculate_control_metrics(robot_info, target_pos)\n\n                    # Print metrics every 100 steps\n                    if i % 100 == 0:\n                        print(f\"Robot {j} (Type: {robot_info['config']['type']}): \"\n                              f\"Error={metrics.get('tracking_error', 0):.3f}m, \"\n                              f\"Accuracy={metrics.get('position_accuracy', 0):.3f}\")\n\n        print(\"Control validation test completed\")\n\n# Create and run the control validation system\nif __name__ == \"__main__\":\n    validation_sys = ControlValidationSystem()\n    validation_sys.run_validation_test(steps=1500)\n"})}),"\n",(0,o.jsx)(e.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,o.jsx)(e.h3,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Control instability or oscillation"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Adjust PID parameters (reduce kp, increase ki/d)"}),"\n",(0,o.jsx)(e.li,{children:"Check time step consistency"}),"\n",(0,o.jsx)(e.li,{children:"Verify sensor feedback accuracy"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Path planning failures"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Verify grid resolution is appropriate"}),"\n",(0,o.jsx)(e.li,{children:"Check obstacle detection"}),"\n",(0,o.jsx)(e.li,{children:"Ensure start/goal positions are valid"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Behavior tree execution issues"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Verify node connections"}),"\n",(0,o.jsx)(e.li,{children:"Check condition functions return proper values"}),"\n",(0,o.jsx)(e.li,{children:"Ensure actions update state correctly"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"ROS integration problems"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Verify network configuration"}),"\n",(0,o.jsx)(e.li,{children:"Check topic/service availability"}),"\n",(0,o.jsx)(e.li,{children:"Ensure proper message types"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Performance issues"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Reduce control frequency for complex systems"}),"\n",(0,o.jsx)(e.li,{children:"Optimize path planning algorithms"}),"\n",(0,o.jsx)(e.li,{children:"Use appropriate simulation settings"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"assessment-questions",children:"Assessment Questions"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"How do you tune PID controller parameters for optimal performance?"}),"\n",(0,o.jsx)(e.li,{children:"What are the key differences between A* and Dijkstra path planning algorithms?"}),"\n",(0,o.jsx)(e.li,{children:"How would you implement obstacle avoidance in real-time navigation?"}),"\n",(0,o.jsx)(e.li,{children:"What metrics would you use to evaluate control system performance?"}),"\n",(0,o.jsx)(e.li,{children:"How do you handle dynamic obstacles in path planning?"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"extension-exercises",children:"Extension Exercises"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Implement a full navigation stack with local and global planners"}),"\n",(0,o.jsx)(e.li,{children:"Create a manipulation control system for robotic arms"}),"\n",(0,o.jsx)(e.li,{children:"Implement reinforcement learning for navigation policy"}),"\n",(0,o.jsx)(e.li,{children:"Create a multi-robot coordination system"}),"\n",(0,o.jsx)(e.li,{children:"Implement advanced control techniques like MPC or LQR"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"In this lab, you successfully:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Implemented path planning algorithms (A*) in Isaac Sim"}),"\n",(0,o.jsx)(e.li,{children:"Created motion control systems with PID controllers"}),"\n",(0,o.jsx)(e.li,{children:"Integrated planning and control with ROS navigation stack"}),"\n",(0,o.jsx)(e.li,{children:"Developed behavior trees for complex navigation tasks"}),"\n",(0,o.jsx)(e.li,{children:"Validated control system performance and stability"}),"\n",(0,o.jsx)(e.li,{children:"Tested various control strategies in simulation"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"These skills are essential for developing autonomous robotic systems capable of navigating and performing tasks in complex environments. The combination of path planning, motion control, and behavioral decision-making forms the foundation of autonomous robotics systems."})]})}function m(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(p,{...n})}):p(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>s});var o=t(6540);const r={},i=o.createContext(r);function a(n){const e=o.useContext(i);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),o.createElement(i.Provider,{value:e},n.children)}}}]);