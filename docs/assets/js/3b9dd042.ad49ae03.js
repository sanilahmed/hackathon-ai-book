"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[6085],{8453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>a});var s=t(6540);const o={},i=s.createContext(o);function r(n){const e=s.useContext(i);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),s.createElement(i.Provider,{value:e},n.children)}},9802:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var s=t(4848),o=t(8453);const i={},r="Lab 2.4: Multi-Environment Synchronization",a={id:"modules/lab-exercises/lab-2-4-multi-environment-synchronization",title:"Lab 2.4: Multi-Environment Synchronization",description:"Overview",source:"@site/docs/modules/lab-exercises/lab-2-4-multi-environment-synchronization.md",sourceDirName:"modules/lab-exercises",slug:"/modules/lab-exercises/lab-2-4-multi-environment-synchronization",permalink:"/hackathon-ai-book/modules/lab-exercises/lab-2-4-multi-environment-synchronization",draft:!1,unlisted:!1,editUrl:"https://github.com/sanilahmed/hackathon-ai-book/tree/main/docs/modules/lab-exercises/lab-2-4-multi-environment-synchronization.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Lab 2.3: Unity Robotics Integration",permalink:"/hackathon-ai-book/modules/lab-exercises/lab-2-3-unity-robotics-integration"},next:{title:"Module 2 References: Digital Twin (Gazebo + Unity)",permalink:"/hackathon-ai-book/modules/digital-twin/references"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Objectives",id:"objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Duration",id:"duration",level:2},{value:"Exercise 1: Time Synchronization Fundamentals",id:"exercise-1-time-synchronization-fundamentals",level:2},{value:"Step 1: Understand time synchronization concepts",id:"step-1-understand-time-synchronization-concepts",level:3},{value:"Step 2: Create a time synchronization node",id:"step-2-create-a-time-synchronization-node",level:3},{value:"Exercise 2: TF Tree Synchronization",id:"exercise-2-tf-tree-synchronization",level:2},{value:"Step 1: Create TF synchronization node",id:"step-1-create-tf-synchronization-node",level:3},{value:"Exercise 3: Robot State Synchronization",id:"exercise-3-robot-state-synchronization",level:2},{value:"Step 1: Create robot state synchronization",id:"step-1-create-robot-state-synchronization",level:3},{value:"Exercise 4: Gazebo-Unity Bridge Configuration",id:"exercise-4-gazebo-unity-bridge-configuration",level:2},{value:"Step 1: Create Gazebo-Unity bridge launch file",id:"step-1-create-gazebo-unity-bridge-launch-file",level:3},{value:"Exercise 5: Unity Synchronization Scripts",id:"exercise-5-unity-synchronization-scripts",level:2},{value:"Step 1: Create Unity synchronization scripts",id:"step-1-create-unity-synchronization-scripts",level:3},{value:"Exercise 6: Validation and Testing",id:"exercise-6-validation-and-testing",level:2},{value:"Step 1: Create validation tools",id:"step-1-create-validation-tools",level:3},{value:"Exercise 7: Build and Test the Synchronization System",id:"exercise-7-build-and-test-the-synchronization-system",level:2},{value:"Step 1: Update setup.py",id:"step-1-update-setuppy",level:3},{value:"Step 2: Build the package",id:"step-2-build-the-package",level:3},{value:"Step 3: Test the synchronization system",id:"step-3-test-the-synchronization-system",level:3},{value:"Step 4: Test with validation",id:"step-4-test-with-validation",level:3},{value:"Exercise 8: Advanced Synchronization Features",id:"exercise-8-advanced-synchronization-features",level:2},{value:"Step 1: Create a coordinator node",id:"step-1-create-a-coordinator-node",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:3},{value:"Assessment Questions",id:"assessment-questions",level:2},{value:"Extension Exercises",id:"extension-exercises",level:2},{value:"Summary",id:"summary",level:2}];function m(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h1,{id:"lab-24-multi-environment-synchronization",children:"Lab 2.4: Multi-Environment Synchronization"}),"\n",(0,s.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(e.p,{children:"In this lab, you will learn how to synchronize robot states and data across multiple simulation environments (Gazebo, Unity) and ROS. You'll implement time synchronization, TF tree coordination, and state broadcasting to create a cohesive digital twin system where all environments reflect the same robot state."}),"\n",(0,s.jsx)(e.h2,{id:"objectives",children:"Objectives"}),"\n",(0,s.jsx)(e.p,{children:"By the end of this lab, you will be able to:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Implement time synchronization between Gazebo, Unity, and ROS"}),"\n",(0,s.jsx)(e.li,{children:"Create and maintain consistent TF trees across environments"}),"\n",(0,s.jsx)(e.li,{children:"Broadcast robot states from one environment to others"}),"\n",(0,s.jsx)(e.li,{children:"Handle coordinate system transformations between environments"}),"\n",(0,s.jsx)(e.li,{children:"Validate synchronization accuracy and consistency"}),"\n",(0,s.jsx)(e.li,{children:"Create a unified digital twin system"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Completion of Lab 2.1-2.3 (Gazebo, robot modeling, Unity integration)"}),"\n",(0,s.jsx)(e.li,{children:"Understanding of ROS TF trees and coordinate transformations"}),"\n",(0,s.jsx)(e.li,{children:"Basic knowledge of time synchronization concepts"}),"\n",(0,s.jsx)(e.li,{children:"Experience with both Gazebo and Unity environments"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"duration",children:"Duration"}),"\n",(0,s.jsx)(e.p,{children:"3-4 hours"}),"\n",(0,s.jsx)(e.h2,{id:"exercise-1-time-synchronization-fundamentals",children:"Exercise 1: Time Synchronization Fundamentals"}),"\n",(0,s.jsx)(e.h3,{id:"step-1-understand-time-synchronization-concepts",children:"Step 1: Understand time synchronization concepts"}),"\n",(0,s.jsx)(e.p,{children:"Time synchronization is crucial for digital twin systems. We need to ensure all environments operate on the same timeline:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Real-time simulation"}),": All environments run at 1x real-time speed"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Simulated time"}),": All environments use the same simulated time source"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Clock synchronization"}),": All environments publish and subscribe to ",(0,s.jsx)(e.code,{children:"/clock"})," topic"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"step-2-create-a-time-synchronization-node",children:"Step 2: Create a time synchronization node"}),"\n",(0,s.jsx)(e.p,{children:"Create a ROS package for synchronization:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"cd ~/ros2_ws/src\nros2 pkg create --build-type ament_python time_sync_py --dependencies rclpy builtin_interfaces std_msgs rosgraph_msgs\n"})}),"\n",(0,s.jsxs)(e.p,{children:["Create ",(0,s.jsx)(e.code,{children:"~/ros2_ws/src/time_sync_py/time_sync_py/time_synchronizer.py"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom builtin_interfaces.msg import Time\nfrom rosgraph_msgs.msg import Clock\nfrom std_msgs.msg import Header\nimport time\n\n\nclass TimeSynchronizer(Node):\n    def __init__(self):\n        super().__init__('time_synchronizer')\n\n        # Parameters\n        self.declare_parameter('use_sim_time', True)\n        self.declare_parameter('time_step', 0.01)  # 10ms time step\n        self.declare_parameter('real_time_factor', 1.0)\n\n        # Publishers\n        self.clock_pub = self.create_publisher(Clock, '/clock', 10)\n\n        # Subscribers\n        self.gazebo_clock_sub = self.create_subscription(\n            Clock,\n            '/gazebo_clock',\n            self.gazebo_clock_callback,\n            10\n        )\n\n        self.unity_clock_sub = self.create_subscription(\n            Clock,\n            '/unity_clock',\n            self.unity_clock_callback,\n            10\n        )\n\n        # Initialize time\n        self.current_time = self.get_clock().now().nanoseconds / 1e9\n        self.time_step = self.get_parameter('time_step').value\n        self.real_time_factor = self.get_parameter('real_time_factor').value\n\n        # Timer for publishing synchronized time\n        self.timer = self.create_timer(self.time_step, self.publish_synchronized_time)\n\n        self.get_logger().info('Time Synchronizer started')\n\n    def gazebo_clock_callback(self, msg):\n        \"\"\"Receive time from Gazebo simulation.\"\"\"\n        self.current_time = msg.clock.sec + msg.clock.nanosec / 1e9\n        self.get_logger().debug(f'Received time from Gazebo: {self.current_time}')\n\n    def unity_clock_callback(self, msg):\n        \"\"\"Receive time from Unity simulation.\"\"\"\n        self.current_time = msg.clock.sec + msg.clock.nanosec / 1e9\n        self.get_logger().debug(f'Received time from Unity: {self.current_time}')\n\n    def publish_synchronized_time(self):\n        \"\"\"Publish synchronized time to all environments.\"\"\"\n        clock_msg = Clock()\n\n        # Update time based on time step\n        self.current_time += self.time_step\n\n        # Convert to ROS time format\n        total_seconds = int(self.current_time)\n        nanoseconds = int((self.current_time - total_seconds) * 1e9)\n\n        clock_msg.clock.sec = total_seconds\n        clock_msg.clock.nanosec = nanoseconds\n\n        self.clock_pub.publish(clock_msg)\n        self.get_logger().debug(f'Published synchronized time: {self.current_time}')\n\n    def get_synchronized_time(self):\n        \"\"\"Get the current synchronized time.\"\"\"\n        return self.current_time\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    time_sync = TimeSynchronizer()\n\n    try:\n        rclpy.spin(time_sync)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        time_sync.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(e.h2,{id:"exercise-2-tf-tree-synchronization",children:"Exercise 2: TF Tree Synchronization"}),"\n",(0,s.jsx)(e.h3,{id:"step-1-create-tf-synchronization-node",children:"Step 1: Create TF synchronization node"}),"\n",(0,s.jsxs)(e.p,{children:["Create ",(0,s.jsx)(e.code,{children:"~/ros2_ws/src/time_sync_py/time_sync_py/tf_synchronizer.py"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom tf2_msgs.msg import TFMessage\nfrom geometry_msgs.msg import TransformStamped\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Header\nimport tf2_ros\nimport tf2_geometry_msgs\nfrom tf2_ros import TransformBroadcaster, TransformListener, Buffer\nimport threading\nimport time\n\n\nclass TFSynchronizer(Node):\n    def __init__(self):\n        super().__init__(\'tf_synchronizer\')\n\n        # TF buffer and broadcaster\n        self.tf_buffer = Buffer()\n        self.tf_broadcaster = TransformBroadcaster(self)\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n\n        # Publishers for environment-specific TFs\n        self.gazebo_tf_pub = self.create_publisher(TFMessage, \'/gazebo_tf\', 10)\n        self.unity_tf_pub = self.create_publisher(TFMessage, \'/unity_tf\', 10)\n\n        # Subscribers for environment-specific TFs\n        self.gazebo_tf_sub = self.create_subscription(\n            TFMessage,\n            \'/gazebo_tf\',\n            self.gazebo_tf_callback,\n            10\n        )\n\n        self.unity_tf_sub = self.create_subscription(\n            TFMessage,\n            \'/unity_tf\',\n            self.unity_tf_callback,\n            10\n        )\n\n        # Joint states for synchronization\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            \'/joint_states\',\n            self.joint_state_callback,\n            10\n        )\n\n        # Timer for broadcasting synchronized TFs\n        self.timer = self.create_timer(0.05, self.broadcast_synchronized_tfs)  # 20 Hz\n\n        # Store transforms for synchronization\n        self.transforms = {}\n        self.joint_states = {}\n        self.lock = threading.Lock()\n\n        self.get_logger().info(\'TF Synchronizer started\')\n\n    def gazebo_tf_callback(self, msg):\n        """Receive TF transforms from Gazebo."""\n        with self.lock:\n            for transform in msg.transforms:\n                key = f"{transform.header.frame_id}_{transform.child_frame_id}"\n                self.transforms[f"gazebo_{key}"] = transform\n                # Also broadcast to ROS TF tree\n                self.tf_broadcaster.sendTransform(transform)\n\n    def unity_tf_callback(self, msg):\n        """Receive TF transforms from Unity."""\n        with self.lock:\n            for transform in msg.transforms:\n                key = f"{transform.header.frame_id}_{transform.child_frame_id}"\n                self.transforms[f"unity_{key}"] = transform\n                # Also broadcast to ROS TF tree\n                self.tf_broadcaster.sendTransform(transform)\n\n    def joint_state_callback(self, msg):\n        """Receive joint states."""\n        with self.lock:\n            for i, name in enumerate(msg.name):\n                if i < len(msg.position):\n                    self.joint_states[name] = {\n                        \'position\': msg.position[i],\n                        \'velocity\': msg.velocity[i] if i < len(msg.velocity) else 0.0,\n                        \'effort\': msg.effort[i] if i < len(msg.effort) else 0.0\n                    }\n\n    def broadcast_synchronized_tfs(self):\n        """Broadcast synchronized transforms to all environments."""\n        with self.lock:\n            # Create synchronized TF message\n            synchronized_tf_msg = TFMessage()\n            synchronized_tf_msg.transforms = []\n\n            # Add all known transforms\n            for key, transform in self.transforms.items():\n                # Update timestamp to current time\n                transform.header.stamp = self.get_clock().now().to_msg()\n                synchronized_tf_msg.transforms.append(transform)\n\n            # Publish to all environments\n            if synchronized_tf_msg.transforms:\n                self.gazebo_tf_pub.publish(synchronized_tf_msg)\n                self.unity_tf_pub.publish(synchronized_tf_msg)\n\n    def transform_frame(self, transform, from_env, to_env):\n        """Transform coordinates from one environment\'s frame to another."""\n        # In a real implementation, this would handle coordinate system differences\n        # between Gazebo (right-handed) and Unity (left-handed)\n        new_transform = TransformStamped()\n        new_transform.header = transform.header\n        new_transform.child_frame_id = transform.child_frame_id\n        new_transform.transform = transform.transform\n\n        # Apply coordinate transformation if needed\n        # This is a simplified version - real implementation would be more complex\n        if from_env == \'unity\' and to_env == \'gazebo\':\n            # Unity to Gazebo coordinate transformation\n            new_transform.transform.translation.y, new_transform.transform.translation.z = \\\n                new_transform.transform.translation.z, new_transform.transform.translation.y\n            new_transform.transform.rotation.y, new_transform.transform.rotation.z = \\\n                new_transform.transform.rotation.z, new_transform.transform.rotation.y\n\n        return new_transform\n\n    def get_transform(self, target_frame, source_frame, time=0):\n        """Get transform between frames with error handling."""\n        try:\n            transform = self.tf_buffer.lookup_transform(\n                target_frame,\n                source_frame,\n                rclpy.time.Time()\n            )\n            return transform\n        except Exception as e:\n            self.get_logger().warn(f\'Could not transform {source_frame} to {target_frame}: {e}\')\n            return None\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    tf_sync = TFSynchronizer()\n\n    try:\n        rclpy.spin(tf_sync)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        tf_sync.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,s.jsx)(e.h2,{id:"exercise-3-robot-state-synchronization",children:"Exercise 3: Robot State Synchronization"}),"\n",(0,s.jsx)(e.h3,{id:"step-1-create-robot-state-synchronization",children:"Step 1: Create robot state synchronization"}),"\n",(0,s.jsxs)(e.p,{children:["Create ",(0,s.jsx)(e.code,{children:"~/ros2_ws/src/time_sync_py/time_sync_py/robot_state_sync.py"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom nav_msgs.msg import Odometry\nfrom geometry_msgs.msg import Pose, Twist\nfrom std_msgs.msg import Header\nimport threading\nimport time\nimport numpy as np\n\n\nclass RobotStateSynchronizer(Node):\n    def __init__(self):\n        super().__init__('robot_state_synchronizer')\n\n        # Robot state storage\n        self.robot_states = {\n            'gazebo': {'joint_states': {}, 'odometry': None, 'timestamp': 0},\n            'unity': {'joint_states': {}, 'odometry': None, 'timestamp': 0},\n            'ros': {'joint_states': {}, 'odometry': None, 'timestamp': 0}\n        }\n\n        self.lock = threading.Lock()\n\n        # Publishers for each environment\n        self.gazebo_joint_pub = self.create_publisher(JointState, '/gazebo/joint_states', 10)\n        self.unity_joint_pub = self.create_publisher(JointState, '/unity/joint_states', 10)\n        self.ros_joint_pub = self.create_publisher(JointState, '/joint_states', 10)\n\n        self.gazebo_odom_pub = self.create_publisher(Odometry, '/gazebo/odom', 10)\n        self.unity_odom_pub = self.create_publisher(Odometry, '/unity/odom', 10)\n        self.ros_odom_pub = self.create_publisher(Odometry, '/odom', 10)\n\n        # Subscribers from each environment\n        self.gazebo_joint_sub = self.create_subscription(\n            JointState,\n            '/gazebo/joint_states',\n            self.gazebo_joint_callback,\n            10\n        )\n\n        self.unity_joint_sub = self.create_subscription(\n            JointState,\n            '/unity/joint_states',\n            self.unity_joint_callback,\n            10\n        )\n\n        self.ros_joint_sub = self.create_subscription(\n            JointState,\n            '/joint_states',\n            self.ros_joint_callback,\n            10\n        )\n\n        self.gazebo_odom_sub = self.create_subscription(\n            Odometry,\n            '/gazebo/odom',\n            self.gazebo_odom_callback,\n            10\n        )\n\n        self.unity_odom_sub = self.create_subscription(\n            Odometry,\n            '/unity/odom',\n            self.unity_odom_callback,\n            10\n        )\n\n        self.ros_odom_sub = self.create_subscription(\n            Odometry,\n            '/odom',\n            self.ros_odom_callback,\n            10\n        )\n\n        # Timer for synchronization\n        self.sync_timer = self.create_timer(0.05, self.synchronize_states)  # 20 Hz\n\n        self.get_logger().info('Robot State Synchronizer started')\n\n    def gazebo_joint_callback(self, msg):\n        \"\"\"Receive joint states from Gazebo.\"\"\"\n        with self.lock:\n            joint_state = {}\n            for i, name in enumerate(msg.name):\n                if i < len(msg.position):\n                    joint_state[name] = {\n                        'position': msg.position[i],\n                        'velocity': msg.velocity[i] if i < len(msg.velocity) else 0.0,\n                        'effort': msg.effort[i] if i < len(msg.effort) else 0.0\n                    }\n            self.robot_states['gazebo']['joint_states'] = joint_state\n            self.robot_states['gazebo']['timestamp'] = time.time()\n\n    def unity_joint_callback(self, msg):\n        \"\"\"Receive joint states from Unity.\"\"\"\n        with self.lock:\n            joint_state = {}\n            for i, name in enumerate(msg.name):\n                if i < len(msg.position):\n                    joint_state[name] = {\n                        'position': msg.position[i],\n                        'velocity': msg.velocity[i] if i < len(msg.velocity) else 0.0,\n                        'effort': msg.effort[i] if i < len(msg.effort) else 0.0\n                    }\n            self.robot_states['unity']['joint_states'] = joint_state\n            self.robot_states['unity']['timestamp'] = time.time()\n\n    def ros_joint_callback(self, msg):\n        \"\"\"Receive joint states from ROS.\"\"\"\n        with self.lock:\n            joint_state = {}\n            for i, name in enumerate(msg.name):\n                if i < len(msg.position):\n                    joint_state[name] = {\n                        'position': msg.position[i],\n                        'velocity': msg.velocity[i] if i < len(msg.velocity) else 0.0,\n                        'effort': msg.effort[i] if i < len(msg.effort) else 0.0\n                    }\n            self.robot_states['ros']['joint_states'] = joint_state\n            self.robot_states['ros']['timestamp'] = time.time()\n\n    def gazebo_odom_callback(self, msg):\n        \"\"\"Receive odometry from Gazebo.\"\"\"\n        with self.lock:\n            self.robot_states['gazebo']['odometry'] = msg\n            self.robot_states['gazebo']['timestamp'] = time.time()\n\n    def unity_odom_callback(self, msg):\n        \"\"\"Receive odometry from Unity.\"\"\"\n        with self.lock:\n            self.robot_states['unity']['odometry'] = msg\n            self.robot_states['unity']['timestamp'] = time.time()\n\n    def ros_odom_callback(self, msg):\n        \"\"\"Receive odometry from ROS.\"\"\"\n        with self.lock:\n            self.robot_states['ros']['odometry'] = msg\n            self.robot_states['ros']['timestamp'] = time.time()\n\n    def synchronize_states(self):\n        \"\"\"Synchronize robot states across all environments.\"\"\"\n        with self.lock:\n            # Determine the most recent state (or use a specific source)\n            latest_env = self.get_latest_environment()\n\n            if latest_env:\n                # Update all environments with the latest state\n                self.update_all_environments(latest_env)\n\n    def get_latest_environment(self):\n        \"\"\"Get the environment with the most recent state update.\"\"\"\n        latest_time = 0\n        latest_env = None\n\n        for env, state in self.robot_states.items():\n            if state['timestamp'] > latest_time:\n                latest_time = state['timestamp']\n                latest_env = env\n\n        return latest_env\n\n    def update_all_environments(self, source_env):\n        \"\"\"Update all environments with the source environment's state.\"\"\"\n        source_state = self.robot_states[source_env]\n\n        # Update joint states for all environments\n        for env in self.robot_states:\n            if env != source_env and source_state['joint_states']:\n                self.publish_joint_states(env, source_state['joint_states'])\n\n        # Update odometry for all environments\n        if source_state['odometry']:\n            for env in self.robot_states:\n                if env != source_env:\n                    self.publish_odometry(env, source_state['odometry'])\n\n    def publish_joint_states(self, env, joint_states):\n        \"\"\"Publish joint states to a specific environment.\"\"\"\n        msg = JointState()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = f\"{env}_base_link\"\n\n        # Convert joint states dict to message format\n        for joint_name, joint_data in joint_states.items():\n            msg.name.append(joint_name)\n            msg.position.append(joint_data['position'])\n            msg.velocity.append(joint_data['velocity'])\n            msg.effort.append(joint_data['effort'])\n\n        # Publish to appropriate topic\n        if env == 'gazebo':\n            self.gazebo_joint_pub.publish(msg)\n        elif env == 'unity':\n            self.unity_joint_pub.publish(msg)\n        else:  # ros\n            self.ros_joint_pub.publish(msg)\n\n    def publish_odometry(self, env, odometry):\n        \"\"\"Publish odometry to a specific environment.\"\"\"\n        msg = Odometry()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = f\"{env}_odom\"\n        msg.child_frame_id = f\"{env}_base_link\"\n\n        # Copy odometry data\n        msg.pose = odometry.pose\n        msg.twist = odometry.twist\n\n        # Publish to appropriate topic\n        if env == 'gazebo':\n            self.gazebo_odom_pub.publish(msg)\n        elif env == 'unity':\n            self.unity_odom_pub.publish(msg)\n        else:  # ros\n            self.ros_odom_pub.publish(msg)\n\n    def coordinate_transform(self, pose, from_env, to_env):\n        \"\"\"Transform coordinates between different environments.\"\"\"\n        # This would handle coordinate system differences\n        # For example: Unity (left-handed) to ROS (right-handed)\n        new_pose = Pose()\n        new_pose.position = pose.position\n        new_pose.orientation = pose.orientation\n\n        if from_env == 'unity' and to_env == 'ros':\n            # Transform Unity coordinates to ROS coordinates\n            new_pose.position.y, new_pose.position.z = pose.position.z, pose.position.y\n            new_pose.orientation.y, new_pose.orientation.z = pose.orientation.z, pose.orientation.y\n\n        return new_pose\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    robot_sync = RobotStateSynchronizer()\n\n    try:\n        rclpy.spin(robot_sync)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        robot_sync.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(e.h2,{id:"exercise-4-gazebo-unity-bridge-configuration",children:"Exercise 4: Gazebo-Unity Bridge Configuration"}),"\n",(0,s.jsx)(e.h3,{id:"step-1-create-gazebo-unity-bridge-launch-file",children:"Step 1: Create Gazebo-Unity bridge launch file"}),"\n",(0,s.jsxs)(e.p,{children:["Create ",(0,s.jsx)(e.code,{children:"~/ros2_ws/src/time_sync_py/time_sync_py/launch/digital_twin_sync.launch.py"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"import os\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom ament_index_python.packages import get_package_share_directory\n\n\ndef generate_launch_description():\n    # Package directories\n    time_sync_pkg = get_package_share_directory('time_sync_py')\n    gazebo_pkg = get_package_share_directory('gazebo_ros')\n\n    # Launch arguments\n    use_sim_time = DeclareLaunchArgument(\n        'use_sim_time',\n        default_value='true',\n        description='Use simulation (Gazebo) clock if true'\n    )\n\n    # Time synchronizer node\n    time_sync_node = Node(\n        package='time_sync_py',\n        executable='time_synchronizer',\n        name='time_synchronizer',\n        parameters=[{'use_sim_time': LaunchConfiguration('use_sim_time')}],\n        output='screen'\n    )\n\n    # TF synchronizer node\n    tf_sync_node = Node(\n        package='time_sync_py',\n        executable='tf_synchronizer',\n        name='tf_synchronizer',\n        parameters=[{'use_sim_time': LaunchConfiguration('use_sim_time')}],\n        output='screen'\n    )\n\n    # Robot state synchronizer node\n    robot_sync_node = Node(\n        package='time_sync_py',\n        executable='robot_state_sync',\n        name='robot_state_synchronizer',\n        parameters=[{'use_sim_time': LaunchConfiguration('use_sim_time')}],\n        output='screen'\n    )\n\n    # Joint state broadcaster\n    joint_state_broadcaster = Node(\n        package='joint_state_broadcaster',\n        executable='joint_state_broadcaster',\n        parameters=[{'use_sim_time': LaunchConfiguration('use_sim_time')}],\n        output='screen'\n    )\n\n    # Robot state publisher\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        parameters=[{\n            'use_sim_time': LaunchConfiguration('use_sim_time'),\n            'robot_description': '<robot name=\"test\"/>',  # Will be replaced with actual URDF\n        }],\n        output='screen'\n    )\n\n    return LaunchDescription([\n        use_sim_time,\n        time_sync_node,\n        tf_sync_node,\n        robot_sync_node,\n        joint_state_broadcaster,\n        robot_state_publisher,\n    ])\n"})}),"\n",(0,s.jsx)(e.h2,{id:"exercise-5-unity-synchronization-scripts",children:"Exercise 5: Unity Synchronization Scripts"}),"\n",(0,s.jsx)(e.h3,{id:"step-1-create-unity-synchronization-scripts",children:"Step 1: Create Unity synchronization scripts"}),"\n",(0,s.jsxs)(e.p,{children:["Create ",(0,s.jsx)(e.code,{children:"Assets/Scripts/UnityGazeboSync.cs"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-csharp",children:'using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Unity.Robotics.ROSTCPConnector;\nusing Unity.Robotics.ROSTCPConnector.MessageTypes.Std_msgs;\nusing Unity.Robotics.ROSTCPConnector.MessageTypes.Tf2_msgs;\nusing Unity.Robotics.ROSTCPConnector.MessageTypes.Sensor_msgs;\nusing Unity.Robotics.ROSTCPConnector.MessageTypes.Nav_msgs;\nusing Unity.Robotics.ROSTCPConnector.MessageTypes.Geometry_msgs;\n\npublic class UnityGazeboSync : MonoBehaviour\n{\n    ROSConnection ros;\n\n    // ROS topics\n    string clockTopic = "/clock";\n    string jointStatesTopic = "/unity/joint_states";\n    string gazeboJointStatesTopic = "/gazebo/joint_states";\n    string unityTfTopic = "/unity_tf";\n    string gazeboTfTopic = "/gazebo_tf";\n    string unityOdomTopic = "/unity/odom";\n    string gazeboOdomTopic = "/gazebo/odom";\n\n    // Robot components\n    public Transform[] robotJoints;\n    public string[] jointNames;\n\n    // Robot transforms for TF\n    public Transform[] tfTransforms;\n    public string[] tfFrameIds;\n    public string[] tfParentFrameIds;\n\n    // Synchronization timing\n    float lastSyncTime = 0f;\n    float syncInterval = 0.05f; // 20 Hz\n\n    void Start()\n    {\n        ros = ROSConnection.instance;\n\n        // Subscribe to Gazebo joint states\n        ros.Subscribe<JointStateMsg>(gazeboJointStatesTopic, OnGazeboJointStatesReceived);\n\n        // Subscribe to Gazebo TF\n        ros.Subscribe<TFMessage>(gazeboTfTopic, OnGazeboTfReceived);\n\n        // Subscribe to Gazebo odometry\n        ros.Subscribe<OdometryMsg>(gazeboOdomTopic, OnGazeboOdomReceived);\n    }\n\n    void Update()\n    {\n        // Periodically publish Unity states to synchronize\n        if (Time.time - lastSyncTime >= syncInterval)\n        {\n            PublishUnityStates();\n            lastSyncTime = Time.time;\n        }\n    }\n\n    void OnGazeboJointStatesReceived(JointStateMsg jointState)\n    {\n        // Update Unity robot joints based on Gazebo states\n        for (int i = 0; i < jointNames.Length; i++)\n        {\n            if (i < jointState.name.Length)\n            {\n                string jointName = jointState.name[i];\n\n                // Find matching joint\n                for (int j = 0; j < jointNames.Length; j++)\n                {\n                    if (jointNames[j] == jointName && j < jointState.position.Length)\n                    {\n                        // Apply joint position (simplified - you\'d need proper joint mapping)\n                        if (robotJoints[j] != null)\n                        {\n                            // For revolute joints, apply rotation\n                            robotJoints[j].localRotation = Quaternion.Euler(\n                                0,\n                                (float)jointState.position[j] * Mathf.Rad2Deg,\n                                0\n                            );\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    void OnGazeboTfReceived(TFMessage tfMsg)\n    {\n        // Update Unity transforms based on Gazebo TF\n        foreach (var transform in tfMsg.transforms)\n        {\n            string childFrame = transform.child_frame_id;\n\n            // Find corresponding Unity transform\n            for (int i = 0; i < tfFrameIds.Length; i++)\n            {\n                if (tfFrameIds[i] == childFrame)\n                {\n                    if (tfTransforms[i] != null)\n                    {\n                        // Apply transform (with coordinate conversion)\n                        Vector3 position = new Vector3(\n                            (float)transform.transform.translation.x,\n                            (float)transform.transform.translation.z, // Gazebo Z -> Unity Y\n                            (float)transform.transform.translation.y  // Gazebo Y -> Unity Z\n                        );\n\n                        Quaternion rotation = new Quaternion(\n                            (float)transform.transform.rotation.x,\n                            (float)transform.transform.rotation.z, // Gazebo Z -> Unity Y\n                            (float)transform.transform.rotation.y, // Gazebo Y -> Unity Z\n                            (float)transform.transform.rotation.w\n                        );\n\n                        tfTransforms[i].position = position;\n                        tfTransforms[i].rotation = rotation;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    void OnGazeboOdomReceived(OdometryMsg odom)\n    {\n        // Update Unity robot position based on Gazebo odometry\n        Vector3 position = new Vector3(\n            (float)odom.pose.pose.position.x,\n            (float)odom.pose.pose.position.z, // Gazebo Z -> Unity Y\n            (float)odom.pose.pose.position.y  // Gazebo Y -> Unity Z\n        );\n\n        // Apply position to robot base\n        if (transform != null)\n        {\n            transform.position = position;\n\n            // Apply orientation\n            Quaternion rotation = new Quaternion(\n                (float)odom.pose.pose.orientation.x,\n                (float)odom.pose.pose.orientation.z, // Gazebo Z -> Unity Y\n                (float)odom.pose.pose.orientation.y, // Gazebo Y -> Unity Z\n                (float)odom.pose.pose.orientation.w\n            );\n            transform.rotation = rotation;\n        }\n    }\n\n    void PublishUnityStates()\n    {\n        // Publish Unity joint states\n        PublishJointStates();\n\n        // Publish Unity TF\n        PublishTf();\n\n        // Publish Unity odometry\n        PublishOdometry();\n    }\n\n    void PublishJointStates()\n    {\n        JointStateMsg jointState = new JointStateMsg();\n        jointState.header.stamp = new TimeStamp(Time.time);\n        jointState.header.frame_id = "unity_base_link";\n\n        List<string> names = new List<string>();\n        List<double> positions = new List<double>();\n        List<double> velocities = new List<double>();\n        List<double> efforts = new List<double>();\n\n        for (int i = 0; i < robotJoints.Length; i++)\n        {\n            if (robotJoints[i] != null && i < jointNames.Length)\n            {\n                names.Add(jointNames[i]);\n                // Get joint position (simplified)\n                positions.Add(robotJoints[i].localEulerAngles.y * Mathf.Deg2Rad);\n                velocities.Add(0); // Simplified\n                efforts.Add(0);    // Simplified\n            }\n        }\n\n        jointState.name = names.ToArray();\n        jointState.position = positions.ToArray();\n        jointState.velocity = velocities.ToArray();\n        jointState.effort = efforts.ToArray();\n\n        ros.Publish(jointStatesTopic, jointState);\n    }\n\n    void PublishTf()\n    {\n        TFMessage tfMsg = new TFMessage();\n\n        List<Unity.Robotics.ROSTCPConnector.MessageTypes.Geometry_msgs.TransformStamped> transforms =\n            new List<Unity.Robotics.ROSTCPConnector.MessageTypes.Geometry_msgs.TransformStamped>();\n\n        for (int i = 0; i < tfTransforms.Length; i++)\n        {\n            if (tfTransforms[i] != null)\n            {\n                var transformStamped = new Unity.Robotics.ROSTCPConnector.MessageTypes.Geometry_msgs.TransformStamped();\n                transformStamped.header.stamp = new TimeStamp(Time.time);\n                transformStamped.header.frame_id = tfParentFrameIds[i];\n                transformStamped.child_frame_id = tfFrameIds[i];\n\n                // Convert Unity coordinates to ROS coordinates\n                transformStamped.transform.translation.x = tfTransforms[i].position.x;\n                transformStamped.transform.translation.y = tfTransforms[i].position.z; // Unity Z -> ROS Y\n                transformStamped.transform.translation.z = tfTransforms[i].position.y; // Unity Y -> ROS Z\n\n                transformStamped.transform.rotation.x = tfTransforms[i].rotation.x;\n                transformStamped.transform.rotation.y = tfTransforms[i].rotation.z; // Unity Z -> ROS Y\n                transformStamped.transform.rotation.z = tfTransforms[i].rotation.y; // Unity Y -> ROS Z\n                transformStamped.transform.rotation.w = tfTransforms[i].rotation.w;\n\n                transforms.Add(transformStamped);\n            }\n        }\n\n        tfMsg.transforms = transforms.ToArray();\n        ros.Publish(unityTfTopic, tfMsg);\n    }\n\n    void PublishOdometry()\n    {\n        OdometryMsg odom = new OdometryMsg();\n        odom.header.stamp = new TimeStamp(Time.time);\n        odom.header.frame_id = "unity_odom";\n        odom.child_frame_id = "unity_base_link";\n\n        // Position\n        odom.pose.pose.position.x = transform.position.x;\n        odom.pose.pose.position.y = transform.position.z; // Unity Z -> ROS Y\n        odom.pose.pose.position.z = transform.position.y; // Unity Y -> ROS Z\n\n        // Orientation\n        odom.pose.pose.orientation.x = transform.rotation.x;\n        odom.pose.pose.orientation.y = transform.rotation.z; // Unity Z -> ROS Y\n        odom.pose.pose.orientation.z = transform.rotation.y; // Unity Y -> ROS Z\n        odom.pose.pose.orientation.w = transform.rotation.w;\n\n        // Velocity (simplified)\n        odom.twist.twist.linear.x = 0;\n        odom.twist.twist.linear.y = 0;\n        odom.twist.twist.linear.z = 0;\n        odom.twist.twist.angular.x = 0;\n        odom.twist.twist.angular.y = 0;\n        odom.twist.twist.angular.z = 0;\n\n        ros.Publish(unityOdomTopic, odom);\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"exercise-6-validation-and-testing",children:"Exercise 6: Validation and Testing"}),"\n",(0,s.jsx)(e.h3,{id:"step-1-create-validation-tools",children:"Step 1: Create validation tools"}),"\n",(0,s.jsxs)(e.p,{children:["Create ",(0,s.jsx)(e.code,{children:"~/ros2_ws/src/time_sync_py/time_sync_py/sync_validator.py"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom nav_msgs.msg import Odometry\nfrom tf2_msgs.msg import TFMessage\nfrom std_msgs.msg import Float32\nimport time\nimport numpy as np\n\n\nclass SyncValidator(Node):\n    def __init__(self):\n        super().__init__('sync_validator')\n\n        # Data storage for validation\n        self.gazebo_data = {'joint_states': {}, 'odometry': None, 'timestamp': 0}\n        self.unity_data = {'joint_states': {}, 'odometry': None, 'timestamp': 0}\n        self.ros_data = {'joint_states': {}, 'odometry': None, 'timestamp': 0}\n\n        # Validation metrics\n        self.sync_accuracy = 0.0\n        self.time_drift = 0.0\n        self.position_error = 0.0\n\n        # Subscribers for all environments\n        self.gazebo_joint_sub = self.create_subscription(\n            JointState,\n            '/gazebo/joint_states',\n            self.gazebo_joint_callback,\n            10\n        )\n\n        self.unity_joint_sub = self.create_subscription(\n            JointState,\n            '/unity/joint_states',\n            self.unity_joint_callback,\n            10\n        )\n\n        self.ros_joint_sub = self.create_subscription(\n            JointState,\n            '/joint_states',\n            self.ros_joint_callback,\n            10\n        )\n\n        self.gazebo_odom_sub = self.create_subscription(\n            Odometry,\n            '/gazebo/odom',\n            self.gazebo_odom_callback,\n            10\n        )\n\n        self.unity_odom_sub = self.create_subscription(\n            Odometry,\n            '/unity/odom',\n            self.unity_odom_callback,\n            10\n        )\n\n        self.ros_odom_sub = self.create_subscription(\n            Odometry,\n            '/odom',\n            self.ros_odom_callback,\n            10\n        )\n\n        # Publishers for validation metrics\n        self.sync_accuracy_pub = self.create_publisher(Float32, '/sync_accuracy', 10)\n        self.time_drift_pub = self.create_publisher(Float32, '/time_drift', 10)\n        self.position_error_pub = self.create_publisher(Float32, '/position_error', 10)\n\n        # Timer for validation\n        self.validation_timer = self.create_timer(1.0, self.validate_synchronization)\n\n        self.get_logger().info('Synchronization Validator started')\n\n    def gazebo_joint_callback(self, msg):\n        \"\"\"Receive joint states from Gazebo.\"\"\"\n        joint_state = {}\n        for i, name in enumerate(msg.name):\n            if i < len(msg.position):\n                joint_state[name] = msg.position[i]\n        self.gazebo_data['joint_states'] = joint_state\n        self.gazebo_data['timestamp'] = time.time()\n\n    def unity_joint_callback(self, msg):\n        \"\"\"Receive joint states from Unity.\"\"\"\n        joint_state = {}\n        for i, name in enumerate(msg.name):\n            if i < len(msg.position):\n                joint_state[name] = msg.position[i]\n        self.unity_data['joint_states'] = joint_state\n        self.unity_data['timestamp'] = time.time()\n\n    def ros_joint_callback(self, msg):\n        \"\"\"Receive joint states from ROS.\"\"\"\n        joint_state = {}\n        for i, name in enumerate(msg.name):\n            if i < len(msg.position):\n                joint_state[name] = msg.position[i]\n        self.ros_data['joint_states'] = joint_state\n        self.ros_data['timestamp'] = time.time()\n\n    def gazebo_odom_callback(self, msg):\n        \"\"\"Receive odometry from Gazebo.\"\"\"\n        self.gazebo_data['odometry'] = msg\n        self.gazebo_data['timestamp'] = time.time()\n\n    def unity_odom_callback(self, msg):\n        \"\"\"Receive odometry from Unity.\"\"\"\n        self.unity_data['odometry'] = msg\n        self.unity_data['timestamp'] = time.time()\n\n    def ros_odom_callback(self, msg):\n        \"\"\"Receive odometry from ROS.\"\"\"\n        self.ros_data['odometry'] = msg\n        self.ros_data['timestamp'] = time.time()\n\n    def validate_synchronization(self):\n        \"\"\"Validate synchronization between all environments.\"\"\"\n        # Calculate time synchronization accuracy\n        time_drift = self.calculate_time_drift()\n\n        # Calculate position synchronization accuracy\n        position_error = self.calculate_position_error()\n\n        # Calculate overall sync accuracy\n        sync_accuracy = self.calculate_sync_accuracy(time_drift, position_error)\n\n        # Publish validation metrics\n        accuracy_msg = Float32()\n        accuracy_msg.data = sync_accuracy\n        self.sync_accuracy_pub.publish(accuracy_msg)\n\n        drift_msg = Float32()\n        drift_msg.data = time_drift\n        self.time_drift_pub.publish(drift_msg)\n\n        error_msg = Float32()\n        error_msg.data = position_error\n        self.position_error_pub.publish(error_msg)\n\n        # Log validation results\n        self.get_logger().info(\n            f'Sync Validation - Accuracy: {sync_accuracy:.3f}, '\n            f'Time Drift: {time_drift:.3f}s, Position Error: {position_error:.3f}m'\n        )\n\n    def calculate_time_drift(self):\n        \"\"\"Calculate time drift between environments.\"\"\"\n        timestamps = [\n            self.gazebo_data['timestamp'],\n            self.unity_data['timestamp'],\n            self.ros_data['timestamp']\n        ]\n\n        if any(ts == 0 for ts in timestamps):\n            return float('inf')  # Not enough data yet\n\n        # Calculate standard deviation of timestamps\n        mean_time = sum(timestamps) / len(timestamps)\n        variance = sum((ts - mean_time) ** 2 for ts in timestamps) / len(timestamps)\n        time_drift = variance ** 0.5\n\n        return time_drift\n\n    def calculate_position_error(self):\n        \"\"\"Calculate position error between environments.\"\"\"\n        positions = []\n\n        # Extract positions from odometry data\n        for data in [self.gazebo_data, self.unity_data, self.ros_data]:\n            if data['odometry'] is not None:\n                pos = data['odometry'].pose.pose.position\n                positions.append(np.array([pos.x, pos.y, pos.z]))\n\n        if len(positions) < 2:\n            return float('inf')  # Not enough data\n\n        # Calculate pairwise distances and return mean\n        total_error = 0\n        pairs = 0\n        for i in range(len(positions)):\n            for j in range(i + 1, len(positions)):\n                distance = np.linalg.norm(positions[i] - positions[j])\n                total_error += distance\n                pairs += 1\n\n        return total_error / pairs if pairs > 0 else 0\n\n    def calculate_sync_accuracy(self, time_drift, position_error):\n        \"\"\"Calculate overall synchronization accuracy.\"\"\"\n        # Normalize metrics to 0-1 scale (lower is better)\n        max_acceptable_drift = 0.1  # 100ms\n        max_acceptable_error = 0.1  # 10cm\n\n        drift_score = max(0, 1 - time_drift / max_acceptable_drift)\n        error_score = max(0, 1 - position_error / max_acceptable_error)\n\n        # Weighted average\n        accuracy = 0.5 * drift_score + 0.5 * error_score\n\n        return min(1.0, max(0.0, accuracy))\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    validator = SyncValidator()\n\n    try:\n        rclpy.spin(validator)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        validator.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(e.h2,{id:"exercise-7-build-and-test-the-synchronization-system",children:"Exercise 7: Build and Test the Synchronization System"}),"\n",(0,s.jsx)(e.h3,{id:"step-1-update-setuppy",children:"Step 1: Update setup.py"}),"\n",(0,s.jsxs)(e.p,{children:["Edit ",(0,s.jsx)(e.code,{children:"~/ros2_ws/src/time_sync_py/setup.py"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"from setuptools import setup\nimport os\nfrom glob import glob\n\npackage_name = 'time_sync_py'\n\nsetup(\n    name=package_name,\n    version='0.0.0',\n    packages=[package_name],\n    data_files=[\n        ('share/ament_index/resource_index/packages',\n            ['resource/' + package_name]),\n        ('share/' + package_name, ['package.xml']),\n        (os.path.join('share', package_name, 'launch'), glob('launch/*.launch.py')),\n    ],\n    install_requires=['setuptools'],\n    zip_safe=True,\n    maintainer='Your Name',\n    maintainer_email='your.email@example.com',\n    description='Time and state synchronization for digital twin',\n    license='Apache License 2.0',\n    tests_require=['pytest'],\n    entry_points={\n        'console_scripts': [\n            'time_synchronizer = time_sync_py.time_synchronizer:main',\n            'tf_synchronizer = time_sync_py.tf_synchronizer:main',\n            'robot_state_sync = time_sync_py.robot_state_sync:main',\n            'sync_validator = time_sync_py.sync_validator:main',\n        ],\n    },\n)\n"})}),"\n",(0,s.jsx)(e.h3,{id:"step-2-build-the-package",children:"Step 2: Build the package"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"cd ~/ros2_ws\ncolcon build --packages-select time_sync_py\nsource ~/ros2_ws/install/setup.bash\n"})}),"\n",(0,s.jsx)(e.h3,{id:"step-3-test-the-synchronization-system",children:"Step 3: Test the synchronization system"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Run the complete synchronization system\nros2 launch time_sync_py digital_twin_sync.launch.py\n"})}),"\n",(0,s.jsx)(e.h3,{id:"step-4-test-with-validation",children:"Step 4: Test with validation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# In another terminal, run the validation node\nsource ~/ros2_ws/install/setup.bash\nros2 run time_sync_py sync_validator\n"})}),"\n",(0,s.jsx)(e.h2,{id:"exercise-8-advanced-synchronization-features",children:"Exercise 8: Advanced Synchronization Features"}),"\n",(0,s.jsx)(e.h3,{id:"step-1-create-a-coordinator-node",children:"Step 1: Create a coordinator node"}),"\n",(0,s.jsxs)(e.p,{children:["Create ",(0,s.jsx)(e.code,{children:"~/ros2_ws/src/time_sync_py/time_sync_py/sync_coordinator.py"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Bool, String\nfrom sensor_msgs.msg import JointState\nfrom nav_msgs.msg import Odometry\nimport time\n\n\nclass SyncCoordinator(Node):\n    def __init__(self):\n        super().__init__(\'sync_coordinator\')\n\n        # State management\n        self.sync_enabled = True\n        self.primary_environment = \'gazebo\'  # Which environment leads\n        self.last_sync_time = time.time()\n\n        # Publishers\n        self.sync_control_pub = self.create_publisher(Bool, \'/sync_control\', 10)\n        self.sync_status_pub = self.create_publisher(String, \'/sync_status\', 10)\n\n        # Subscribers\n        self.gazebo_sync_sub = self.create_subscription(\n            String,\n            \'/gazebo/sync_status\',\n            self.gazebo_sync_callback,\n            10\n        )\n\n        self.unity_sync_sub = self.create_subscription(\n            String,\n            \'/unity/sync_status\',\n            self.unity_sync_callback,\n            10\n        )\n\n        # Timer for coordination\n        self.coordination_timer = self.create_timer(0.1, self.coordinate_sync)\n\n        self.get_logger().info(\'Synchronization Coordinator started\')\n\n    def gazebo_sync_callback(self, msg):\n        """Receive sync status from Gazebo."""\n        self.get_logger().debug(f\'Gazebo sync status: {msg.data}\')\n\n    def unity_sync_callback(self, msg):\n        """Receive sync status from Unity."""\n        self.get_logger().debug(f\'Unity sync status: {msg.data}\')\n\n    def coordinate_sync(self):\n        """Coordinate synchronization activities."""\n        # Check if sync should be enabled/disabled\n        if self.should_adjust_sync():\n            self.toggle_sync()\n\n        # Check if primary environment should be changed\n        if self.should_change_primary():\n            self.change_primary_environment()\n\n        # Publish sync status\n        status_msg = String()\n        status_msg.data = f"Primary: {self.primary_environment}, Enabled: {self.sync_enabled}"\n        self.sync_status_pub.publish(status_msg)\n\n    def should_adjust_sync(self):\n        """Determine if sync should be adjusted."""\n        # Implement logic to determine if sync needs adjustment\n        # For example, based on validation metrics\n        return False\n\n    def toggle_sync(self):\n        """Toggle synchronization on/off."""\n        self.sync_enabled = not self.sync_enabled\n        control_msg = Bool()\n        control_msg.data = self.sync_enabled\n        self.sync_control_pub.publish(control_msg)\n        self.get_logger().info(f\'Synchronization {"enabled" if self.sync_enabled else "disabled"}\')\n\n    def should_change_primary(self):\n        """Determine if primary environment should be changed."""\n        # Implement logic to determine if primary environment should change\n        # For example, based on which environment has the most recent/accurate data\n        return False\n\n    def change_primary_environment(self):\n        """Change which environment is considered primary."""\n        if self.primary_environment == \'gazebo\':\n            self.primary_environment = \'unity\'\n        else:\n            self.primary_environment = \'gazebo\'\n        self.get_logger().info(f\'Primary environment changed to: {self.primary_environment}\')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    coordinator = SyncCoordinator()\n\n    try:\n        rclpy.spin(coordinator)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        coordinator.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,s.jsx)(e.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,s.jsx)(e.h3,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Time synchronization drift"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Ensure all environments use the same time source"}),"\n",(0,s.jsxs)(e.li,{children:["Check that ",(0,s.jsx)(e.code,{children:"use_sim_time"})," parameter is properly set"]}),"\n",(0,s.jsx)(e.li,{children:"Verify that simulation rates are consistent"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"TF tree conflicts"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Use environment-specific frame prefixes (gazebo_",(0,s.jsx)(e.em,{children:", unity_"}),")"]}),"\n",(0,s.jsx)(e.li,{children:"Ensure TF trees are properly connected"}),"\n",(0,s.jsx)(e.li,{children:"Check for circular dependencies in TF"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Joint state mapping issues"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Verify joint names match across environments"}),"\n",(0,s.jsx)(e.li,{children:"Check joint limits and ranges are consistent"}),"\n",(0,s.jsx)(e.li,{children:"Ensure proper coordinate system transformations"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Performance problems"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Reduce synchronization frequency for less critical updates"}),"\n",(0,s.jsx)(e.li,{children:"Use appropriate data types and message sizes"}),"\n",(0,s.jsx)(e.li,{children:"Consider using latching for static transforms"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Coordinate system mismatches"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Implement proper coordinate transformation functions"}),"\n",(0,s.jsx)(e.li,{children:"Verify axis mappings between environments"}),"\n",(0,s.jsx)(e.li,{children:"Test with simple geometric shapes first"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"assessment-questions",children:"Assessment Questions"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"How do you handle coordinate system differences between Gazebo and Unity?"}),"\n",(0,s.jsxs)(e.li,{children:["What is the role of the ",(0,s.jsx)(e.code,{children:"/clock"})," topic in time synchronization?"]}),"\n",(0,s.jsx)(e.li,{children:"How would you validate that all environments are properly synchronized?"}),"\n",(0,s.jsx)(e.li,{children:"What are the challenges in synchronizing joint states across environments?"}),"\n",(0,s.jsx)(e.li,{children:"How can you optimize the synchronization frequency for performance?"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"extension-exercises",children:"Extension Exercises"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Implement fault tolerance in the synchronization system"}),"\n",(0,s.jsx)(e.li,{children:"Add network latency compensation for distributed environments"}),"\n",(0,s.jsx)(e.li,{children:"Create a visualization tool to monitor synchronization quality"}),"\n",(0,s.jsx)(e.li,{children:"Implement selective synchronization for different robot parts"}),"\n",(0,s.jsx)(e.li,{children:"Add machine learning-based prediction for smoother synchronization"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(e.p,{children:"In this lab, you successfully:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Implemented time synchronization between Gazebo, Unity, and ROS"}),"\n",(0,s.jsx)(e.li,{children:"Created TF tree synchronization across environments"}),"\n",(0,s.jsx)(e.li,{children:"Developed robot state synchronization mechanisms"}),"\n",(0,s.jsx)(e.li,{children:"Validated synchronization accuracy and consistency"}),"\n",(0,s.jsx)(e.li,{children:"Created a unified digital twin coordination system"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"These skills are essential for creating robust digital twin systems where multiple simulation environments maintain consistent robot states. The synchronization mechanisms you've implemented ensure that actions in one environment are properly reflected in others, enabling seamless integration between different simulation and visualization platforms."})]})}function d(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(m,{...n})}):m(n)}}}]);