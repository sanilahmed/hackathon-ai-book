"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[9558],{748:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>t,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var o=i(4848),a=i(8453);const r={},t="Gazebo Setup for Humanoid Robotics",s={id:"modules/digital-twin/gazebo-setup",title:"Gazebo Setup for Humanoid Robotics",description:"Introduction to Gazebo",source:"@site/docs/modules/digital-twin/gazebo-setup.md",sourceDirName:"modules/digital-twin",slug:"/modules/digital-twin/gazebo-setup",permalink:"/hackathon-ai-book/modules/digital-twin/gazebo-setup",draft:!1,unlisted:!1,editUrl:"https://github.com/sanilahmed/hackathon-ai-book/tree/main/docs/modules/digital-twin/gazebo-setup.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Module 2: Digital Twin (Gazebo + Unity)",permalink:"/hackathon-ai-book/modules/digital-twin/"},next:{title:"Unity Integration for Humanoid Robotics",permalink:"/hackathon-ai-book/modules/digital-twin/unity-integration"}},l={},c=[{value:"Introduction to Gazebo",id:"introduction-to-gazebo",level:2},{value:"Installing Gazebo Garden",id:"installing-gazebo-garden",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Installation Steps",id:"installation-steps",level:3},{value:"Verification",id:"verification",level:3},{value:"Configuring Gazebo for Humanoid Robots",id:"configuring-gazebo-for-humanoid-robots",level:2},{value:"Physics Engine Configuration",id:"physics-engine-configuration",level:3},{value:"World Setup",id:"world-setup",level:3},{value:"Converting URDF to SDF",id:"converting-urdf-to-sdf",level:2},{value:"Method 1: Direct URDF Integration",id:"method-1-direct-urdf-integration",level:3},{value:"Method 2: Conversion to SDF",id:"method-2-conversion-to-sdf",level:3},{value:"Setting Up Humanoid Robot Simulation",id:"setting-up-humanoid-robot-simulation",level:2},{value:"Creating a Robot Spawn Launch File",id:"creating-a-robot-spawn-launch-file",level:3},{value:"Adding Sensors to the Humanoid Robot",id:"adding-sensors-to-the-humanoid-robot",level:2},{value:"LiDAR Sensor Configuration",id:"lidar-sensor-configuration",level:3},{value:"IMU Sensor Configuration",id:"imu-sensor-configuration",level:3},{value:"Camera Sensor Configuration",id:"camera-sensor-configuration",level:3},{value:"Running the Simulation",id:"running-the-simulation",level:2},{value:"Launching the Complete Simulation",id:"launching-the-complete-simulation",level:3},{value:"Controlling the Robot in Simulation",id:"controlling-the-robot-in-simulation",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Gazebo Not Starting",id:"gazebo-not-starting",level:3},{value:"Robot Falls Through Ground",id:"robot-falls-through-ground",level:3},{value:"Sensor Data Not Publishing",id:"sensor-data-not-publishing",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Summary",id:"summary",level:2},{value:"Learning Check",id:"learning-check",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h1,{id:"gazebo-setup-for-humanoid-robotics",children:"Gazebo Setup for Humanoid Robotics"}),"\n",(0,o.jsx)(e.h2,{id:"introduction-to-gazebo",children:"Introduction to Gazebo"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo is a 3D simulation environment that enables accurate and efficient testing of robotics algorithms, robot design, and software integration. For humanoid robotics, Gazebo provides realistic physics simulation, high-quality graphics, and convenient programmatic interfaces that allow for rapid development and testing of complex robotic systems."}),"\n",(0,o.jsx)(e.h2,{id:"installing-gazebo-garden",children:"Installing Gazebo Garden"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo Garden is the recommended version for use with ROS 2 Humble Hawksbill. The installation process involves setting up the simulation environment with proper physics engines and rendering capabilities."}),"\n",(0,o.jsx)(e.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsx)(e.p,{children:"Before installing Gazebo, ensure you have:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Ubuntu 22.04 LTS"}),"\n",(0,o.jsx)(e.li,{children:"ROS 2 Humble Hawksbill installed"}),"\n",(0,o.jsx)(e.li,{children:"Graphics drivers properly configured (especially if using GPU acceleration)"}),"\n",(0,o.jsx)(e.li,{children:"At least 4GB of RAM (8GB+ recommended for complex simulations)"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"installation-steps",children:"Installation Steps"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Update package list\nsudo apt update\n\n# Install Gazebo Garden\nsudo apt install gz-garden\n\n# Install additional Gazebo plugins and tools\nsudo apt install libgazebo-dev\nsudo apt install ros-humble-gazebo-ros-pkgs\nsudo apt install ros-humble-gazebo-ros2-control\nsudo apt install ros-humble-gazebo-dev\n"})}),"\n",(0,o.jsx)(e.h3,{id:"verification",children:"Verification"}),"\n",(0,o.jsx)(e.p,{children:"After installation, verify Gazebo is working correctly:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Check Gazebo version\ngz --version\n\n# Launch Gazebo GUI\ngz sim\n\n# Launch with a simple world\ngz sim -r -v 4 shapes.sdf\n"})}),"\n",(0,o.jsx)(e.h2,{id:"configuring-gazebo-for-humanoid-robots",children:"Configuring Gazebo for Humanoid Robots"}),"\n",(0,o.jsx)(e.h3,{id:"physics-engine-configuration",children:"Physics Engine Configuration"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo supports multiple physics engines including ODE, Bullet, DART, and SimBody. For humanoid robots, ODE (Open Dynamics Engine) is often the best choice due to its balance of accuracy and performance."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Example physics configuration in SDF --\x3e\n<physics type="ode">\n  <max_step_size>0.001</max_step_size>\n  <real_time_factor>1.0</real_time_factor>\n  <real_time_update_rate>1000</real_time_update_rate>\n  <gravity>0 0 -9.8</gravity>\n</physics>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"world-setup",children:"World Setup"}),"\n",(0,o.jsx)(e.p,{children:"Create a world file for humanoid robot simulation:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="humanoid_world">\n    \x3c!-- Include a ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Include a sun for lighting --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Physics configuration --\x3e\n    <physics name="1ms" type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n\n    \x3c!-- Your humanoid robot will be inserted here --\x3e\n  </world>\n</sdf>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"converting-urdf-to-sdf",children:"Converting URDF to SDF"}),"\n",(0,o.jsx)(e.p,{children:"Since Gazebo works with SDF (Simulation Description Format) but ROS 2 typically uses URDF (Unified Robot Description Format), you'll need to convert your humanoid robot model:"}),"\n",(0,o.jsx)(e.h3,{id:"method-1-direct-urdf-integration",children:"Method 1: Direct URDF Integration"}),"\n",(0,o.jsxs)(e.p,{children:["Gazebo can directly load URDF files through the ",(0,o.jsx)(e.code,{children:"libgazebo_ros_factory.so"})," plugin:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- In your launch file --\x3e\n<node name="spawn_urdf" pkg="gazebo_ros" type="spawn_entity.py"\n      args="-entity my_robot -topic robot_description -x 0 -y 0 -z 1"/>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"method-2-conversion-to-sdf",children:"Method 2: Conversion to SDF"}),"\n",(0,o.jsx)(e.p,{children:"Convert your URDF to SDF format:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Install the conversion tool\nsudo apt install ros-humble-xacro\n\n# Convert URDF to SDF\nros2 run xacro xacro --inorder /path/to/your/robot.urdf.xacro > robot.sdf\n"})}),"\n",(0,o.jsx)(e.h2,{id:"setting-up-humanoid-robot-simulation",children:"Setting Up Humanoid Robot Simulation"}),"\n",(0,o.jsx)(e.h3,{id:"creating-a-robot-spawn-launch-file",children:"Creating a Robot Spawn Launch File"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"import os\nfrom launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\nfrom launch.substitutions import Command\nfrom ament_index_python.packages import get_package_share_directory\n\n\ndef generate_launch_description():\n    # Get the package share directory\n    pkg_share = get_package_share_directory('humanoid_description')\n\n    # Get URDF file path\n    urdf_path = os.path.join(pkg_share, 'urdf', 'humanoid.urdf.xacro')\n\n    # Use xacro to process the file\n    robot_description = Command(['xacro ', urdf_path])\n\n    # Gazebo server and client\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([os.path.join(\n            get_package_share_directory('gazebo_ros'), 'launch'), '/gazebo.launch.py']),\n    )\n\n    # Spawn the robot in Gazebo\n    spawn_entity = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=['-topic', 'robot_description',\n                   '-entity', 'humanoid_robot',\n                   '-x', '0.0',\n                   '-y', '0.0',\n                   '-z', '1.0'],\n        output='screen'\n    )\n\n    # Robot state publisher\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        name='robot_state_publisher',\n        parameters=[{\n            'robot_description': robot_description,\n            'publish_frequency': 50.0\n        }]\n    )\n\n    return LaunchDescription([\n        gazebo,\n        robot_state_publisher,\n        spawn_entity,\n    ])\n"})}),"\n",(0,o.jsx)(e.h2,{id:"adding-sensors-to-the-humanoid-robot",children:"Adding Sensors to the Humanoid Robot"}),"\n",(0,o.jsx)(e.h3,{id:"lidar-sensor-configuration",children:"LiDAR Sensor Configuration"}),"\n",(0,o.jsx)(e.p,{children:"Add a LiDAR sensor to the humanoid robot head:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- In your URDF/Xacro file --\x3e\n<gazebo reference="head">\n  <sensor name="lidar_sensor" type="ray">\n    <pose>0.1 0 0 0 0 0</pose>\n    <ray>\n      <scan>\n        <horizontal>\n          <samples>360</samples>\n          <resolution>1</resolution>\n          <min_angle>-3.14159</min_angle>\n          <max_angle>3.14159</max_angle>\n        </horizontal>\n      </scan>\n      <range>\n        <min>0.1</min>\n        <max>30.0</max>\n        <resolution>0.01</resolution>\n      </range>\n    </ray>\n    <plugin name="lidar_controller" filename="libgazebo_ros_ray_sensor.so">\n      <ros>\n        <namespace>/humanoid</namespace>\n        <remapping>~/out:=scan</remapping>\n      </ros>\n      <output_type>sensor_msgs/LaserScan</output_type>\n      <frame_name>lidar_frame</frame_name>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"imu-sensor-configuration",children:"IMU Sensor Configuration"}),"\n",(0,o.jsx)(e.p,{children:"Add IMU sensors to torso and limbs:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<gazebo reference="torso">\n  <sensor name="imu_sensor" type="imu">\n    <always_on>true</always_on>\n    <update_rate>100</update_rate>\n    <visualize>true</visualize>\n    <plugin name="imu_controller" filename="libgazebo_ros_imu_sensor.so">\n      <ros>\n        <namespace>/humanoid</namespace>\n        <remapping>~/out:=imu</remapping>\n      </ros>\n      <frame_name>imu_frame</frame_name>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"camera-sensor-configuration",children:"Camera Sensor Configuration"}),"\n",(0,o.jsx)(e.p,{children:"Add a depth camera to the head:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<gazebo reference="head">\n  <sensor name="camera" type="depth">\n    <always_on>true</always_on>\n    <update_rate>30</update_rate>\n    <camera name="head">\n      <horizontal_fov>1.047</horizontal_fov>\n      <image>\n        <width>640</width>\n        <height>480</height>\n        <format>R8G8B8</format>\n      </image>\n      <clip>\n        <near>0.1</near>\n        <far>10</far>\n      </clip>\n    </camera>\n    <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n      <ros>\n        <namespace>/humanoid</namespace>\n        <remapping>image_raw:=camera/image_raw</remapping>\n        <remapping>camera_info:=camera/camera_info</remapping>\n      </ros>\n      <frame_name>camera_frame</frame_name>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"running-the-simulation",children:"Running the Simulation"}),"\n",(0,o.jsx)(e.h3,{id:"launching-the-complete-simulation",children:"Launching the Complete Simulation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Source your ROS 2 workspace\nsource install/setup.bash\n\n# Launch the simulation with your humanoid robot\nros2 launch humanoid_description gazebo.launch.py\n"})}),"\n",(0,o.jsx)(e.h3,{id:"controlling-the-robot-in-simulation",children:"Controlling the Robot in Simulation"}),"\n",(0,o.jsx)(e.p,{children:"Once the simulation is running, you can control the robot using ROS 2 topics:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Send joint position commands\nros2 topic pub /humanoid/joint_trajectory_controller/joint_trajectory trajectory_msgs/msg/JointTrajectory \"header:\n  stamp:\n    sec: 0\n    nanosec: 0\n  frame_id: 'base_link'\njoint_names: ['joint1', 'joint2']  # Replace with actual joint names\npoints:\n- positions: [0.0, 0.0]\n  time_from_start:\n    sec: 1\n    nanosec: 0\"\n"})}),"\n",(0,o.jsx)(e.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,o.jsx)(e.h3,{id:"gazebo-not-starting",children:"Gazebo Not Starting"}),"\n",(0,o.jsx)(e.p,{children:"If Gazebo fails to start:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Check that your graphics drivers are properly installed"}),"\n",(0,o.jsx)(e.li,{children:"Verify X11 forwarding if running remotely"}),"\n",(0,o.jsx)(e.li,{children:"Ensure sufficient RAM is available"}),"\n",(0,o.jsxs)(e.li,{children:["Try running with software rendering: ",(0,o.jsx)(e.code,{children:"gazebo --verbose --render-engine=ogre"})]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"robot-falls-through-ground",children:"Robot Falls Through Ground"}),"\n",(0,o.jsx)(e.p,{children:"If your robot falls through the ground:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Verify that collision geometries are properly defined in URDF"}),"\n",(0,o.jsx)(e.li,{children:"Check that the robot has proper mass and inertia values"}),"\n",(0,o.jsx)(e.li,{children:"Ensure joint limits and safety controllers are configured"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"sensor-data-not-publishing",children:"Sensor Data Not Publishing"}),"\n",(0,o.jsx)(e.p,{children:"If sensor data is not publishing:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Verify that Gazebo ROS plugins are properly configured"}),"\n",(0,o.jsxs)(e.li,{children:["Check that the sensor topics are being published: ",(0,o.jsx)(e.code,{children:"ros2 topic list"})]}),"\n",(0,o.jsx)(e.li,{children:"Confirm that the robot state publisher is running"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsx)(e.p,{children:"For complex humanoid robots with multiple sensors:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Adjust Physics Update Rate"}),": Balance accuracy and performance"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Use Simplified Collision Models"}),": Use simpler geometries for collision detection"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Limit Sensor Update Rates"}),": Reduce sensor update rates where possible"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Disable Unnecessary Rendering"}),": Use headless mode for batch simulations"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Model Validation"}),": Always validate URDF/SDF models before simulation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Realistic Parameters"}),": Use realistic mass, inertia, and friction values"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Incremental Testing"}),": Test simple models before adding complexity"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Consistent Units"}),": Maintain consistent units throughout the model"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Documentation"}),": Document all simulation parameters for reproducibility"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo provides a powerful simulation environment for humanoid robotics, enabling realistic physics simulation and sensor modeling. Proper setup involves configuring physics parameters, converting URDF models to SDF format, and integrating with ROS 2 for seamless control and perception. With careful configuration, Gazebo enables effective testing and validation of humanoid robot systems before deployment to physical hardware."}),"\n",(0,o.jsx)(e.h2,{id:"learning-check",children:"Learning Check"}),"\n",(0,o.jsx)(e.p,{children:"After studying this section, you should be able to:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Install and configure Gazebo Garden for ROS 2 Humble"}),"\n",(0,o.jsx)(e.li,{children:"Convert URDF models to SDF format for simulation"}),"\n",(0,o.jsx)(e.li,{children:"Add various sensor types to humanoid robot models"}),"\n",(0,o.jsx)(e.li,{children:"Launch and control humanoid robots in simulation"}),"\n",(0,o.jsx)(e.li,{children:"Troubleshoot common simulation issues"}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>t,x:()=>s});var o=i(6540);const a={},r=o.createContext(a);function t(n){const e=o.useContext(r);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:t(n.components),o.createElement(r.Provider,{value:e},n.children)}}}]);