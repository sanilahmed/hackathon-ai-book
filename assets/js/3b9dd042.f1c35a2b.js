"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[6085],{8453(n,e,t){t.d(e,{R:()=>a,x:()=>r});var i=t(6540);const s={},o=i.createContext(s);function a(n){const e=i.useContext(o);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),i.createElement(o.Provider,{value:e},n.children)}},9802(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var i=t(4848),s=t(8453);const o={sidebar_label:"Lab 2.4: Multi-Environment Synchronization"},a="Lab Exercise 2.4: Multi-Environment Synchronization",r={id:"modules/lab-exercises/lab-2-4-multi-environment-synchronization",title:"Lab Exercise 2.4: Multi-Environment Synchronization",description:"This lab exercise covers synchronizing robot states and behaviors across multiple simulation environments (Gazebo and Unity).",source:"@site/docs/modules/lab-exercises/lab-2-4-multi-environment-synchronization.md",sourceDirName:"modules/lab-exercises",slug:"/modules/lab-exercises/lab-2-4-multi-environment-synchronization",permalink:"/hackathon-ai-book/modules/lab-exercises/lab-2-4-multi-environment-synchronization",draft:!1,unlisted:!1,editUrl:"https://github.com/sanilahmed/hackathon-ai-book/tree/main/docs/modules/lab-exercises/lab-2-4-multi-environment-synchronization.md",tags:[],version:"current",frontMatter:{sidebar_label:"Lab 2.4: Multi-Environment Synchronization"},sidebar:"tutorialSidebar",previous:{title:"Lab 2.3: Unity Robotics Integration",permalink:"/hackathon-ai-book/modules/lab-exercises/lab-2-3-unity-robotics-integration"},next:{title:"References",permalink:"/hackathon-ai-book/modules/digital-twin/references"}},l={},c=[{value:"Objectives",id:"objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Synchronization Architecture",id:"synchronization-architecture",level:2},{value:"Multi-Environment Overview",id:"multi-environment-overview",level:3},{value:"Synchronization Patterns",id:"synchronization-patterns",level:3},{value:"Centralized Synchronization",id:"centralized-synchronization",level:4},{value:"Distributed Synchronization",id:"distributed-synchronization",level:4},{value:"Time Synchronization",id:"time-synchronization",level:2},{value:"Time Management Strategies",id:"time-management-strategies",level:3},{value:"Real-time Synchronization",id:"real-time-synchronization",level:4},{value:"Simulation Time Synchronization",id:"simulation-time-synchronization",level:4},{value:"State Synchronization",id:"state-synchronization",level:2},{value:"Robot State Publisher",id:"robot-state-publisher",level:3},{value:"Sensor Data Synchronization",id:"sensor-data-synchronization",level:3},{value:"Gazebo-Specific Synchronization",id:"gazebo-specific-synchronization",level:2},{value:"Gazebo State Publisher",id:"gazebo-state-publisher",level:3},{value:"Unity-Specific Synchronization",id:"unity-specific-synchronization",level:2},{value:"Unity State Synchronization Script",id:"unity-state-synchronization-script",level:3},{value:"Synchronization Validation",id:"synchronization-validation",level:2},{value:"Validation Node",id:"validation-node",level:3},{value:"Exercise Tasks",id:"exercise-tasks",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Optimization Strategies",id:"optimization-strategies",level:3},{value:"Quality of Service (QoS)",id:"quality-of-service-qos",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Summary",id:"summary",level:2}];function m(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h1,{id:"lab-exercise-24-multi-environment-synchronization",children:"Lab Exercise 2.4: Multi-Environment Synchronization"}),"\n",(0,i.jsx)(e.p,{children:"This lab exercise covers synchronizing robot states and behaviors across multiple simulation environments (Gazebo and Unity)."}),"\n",(0,i.jsx)(e.h2,{id:"objectives",children:"Objectives"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Understand multi-environment synchronization challenges"}),"\n",(0,i.jsx)(e.li,{children:"Implement state synchronization between Gazebo and Unity"}),"\n",(0,i.jsx)(e.li,{children:"Create a unified representation of robot state"}),"\n",(0,i.jsx)(e.li,{children:"Handle time synchronization across environments"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Gazebo simulation environment set up"}),"\n",(0,i.jsx)(e.li,{children:"Unity robotics environment set up"}),"\n",(0,i.jsx)(e.li,{children:"Basic ROS 2 knowledge"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"synchronization-architecture",children:"Synchronization Architecture"}),"\n",(0,i.jsx)(e.h3,{id:"multi-environment-overview",children:"Multi-Environment Overview"}),"\n",(0,i.jsx)(e.p,{children:"In a digital twin system, we need to synchronize:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Robot joint states"}),"\n",(0,i.jsx)(e.li,{children:"Sensor data"}),"\n",(0,i.jsx)(e.li,{children:"Environmental conditions"}),"\n",(0,i.jsx)(e.li,{children:"Time progression"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"synchronization-patterns",children:"Synchronization Patterns"}),"\n",(0,i.jsx)(e.h4,{id:"centralized-synchronization",children:"Centralized Synchronization"}),"\n",(0,i.jsx)(e.p,{children:"One central node manages synchronization between all environments:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"        +------------------+\n        | Synchronization  |\n        |    Node          |\n        +--------+---------+\n                 |\n        +--------+---------+\n        |                |\n    +---v----+      +----v---+\n    | Gazebo |      | Unity  |\n    +--------+      +--------+\n"})}),"\n",(0,i.jsx)(e.h4,{id:"distributed-synchronization",children:"Distributed Synchronization"}),"\n",(0,i.jsx)(e.p,{children:"Each environment maintains its own synchronization logic:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"    +--------+      +--------+\n    | Gazebo |<----\x3e| Unity  |\n    +--------+      +--------+\n         |              |\n         +--------------+\n"})}),"\n",(0,i.jsx)(e.h2,{id:"time-synchronization",children:"Time Synchronization"}),"\n",(0,i.jsx)(e.h3,{id:"time-management-strategies",children:"Time Management Strategies"}),"\n",(0,i.jsx)(e.h4,{id:"real-time-synchronization",children:"Real-time Synchronization"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom builtin_interfaces.msg import Time\nfrom std_msgs.msg import Header\nfrom rclpy.time import Time as ROSTime\n\nclass TimeSynchronizer(Node):\n    def __init__(self):\n        super().__init__('time_synchronizer')\n\n        # Publishers for time synchronization\n        self.gazebo_time_pub = self.create_publisher(Time, 'gazebo/time', 10)\n        self.unity_time_pub = self.create_publisher(Time, 'unity/time', 10)\n\n        # Timer for time synchronization\n        self.timer = self.create_timer(0.01, self.sync_time)  # 100Hz sync\n\n        # Store reference time\n        self.start_time = self.get_clock().now()\n\n    def sync_time(self):\n        # Get current ROS time\n        current_time = self.get_clock().now()\n\n        # Create time message\n        time_msg = current_time.to_msg()\n\n        # Publish to both environments\n        self.gazebo_time_pub.publish(time_msg)\n        self.unity_time_pub.publish(time_msg)\n\n        self.get_logger().debug(f'Synchronized time: {current_time}')\n"})}),"\n",(0,i.jsx)(e.h4,{id:"simulation-time-synchronization",children:"Simulation Time Synchronization"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"class SimulationTimeSynchronizer:\n    def __init__(self):\n        self.gazebo_time = 0.0\n        self.unity_time = 0.0\n        self.last_sync_time = 0.0\n        self.time_scale = 1.0  # 1x, 2x, 0.5x, etc.\n\n    def synchronize_simulation_time(self):\n        # Calculate elapsed time since last sync\n        elapsed = self.get_current_time() - self.last_sync_time\n\n        # Apply time scaling\n        scaled_elapsed = elapsed * self.time_scale\n\n        # Update both simulation times\n        self.gazebo_time += scaled_elapsed\n        self.unity_time += scaled_elapsed\n\n        # Send time updates to both environments\n        self.send_time_to_gazebo(self.gazebo_time)\n        self.send_time_to_unity(self.unity_time)\n\n        # Update last sync time\n        self.last_sync_time = self.get_current_time()\n"})}),"\n",(0,i.jsx)(e.h2,{id:"state-synchronization",children:"State Synchronization"}),"\n",(0,i.jsx)(e.h3,{id:"robot-state-publisher",children:"Robot State Publisher"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"from sensor_msgs.msg import JointState\nfrom nav_msgs.msg import Odometry\nfrom geometry_msgs.msg import TransformStamped\nimport tf2_ros\n\nclass MultiEnvStateSync(Node):\n    def __init__(self):\n        super().__init__('multi_env_state_sync')\n\n        # Publishers for both environments\n        self.gazebo_joint_pub = self.create_publisher(JointState, '/gazebo/joint_states', 10)\n        self.unity_joint_pub = self.create_publisher(JointState, '/unity/joint_states', 10)\n        self.gazebo_odom_pub = self.create_publisher(Odometry, '/gazebo/odom', 10)\n        self.unity_odom_pub = self.create_publisher(Odometry, '/unity/odom', 10)\n\n        # Subscribers for robot state\n        self.joint_sub = self.create_subscription(JointState, '/joint_states', self.joint_state_callback, 10)\n        self.odom_sub = self.create_subscription(Odometry, '/odom', self.odom_callback, 10)\n\n        # TF broadcaster\n        self.tf_broadcaster = tf2_ros.TransformBroadcaster(self)\n\n        # State storage\n        self.current_joint_state = None\n        self.current_odom = None\n\n    def joint_state_callback(self, msg):\n        # Store current state\n        self.current_joint_state = msg\n\n        # Publish to both environments\n        self.publish_to_gazebo_joint(msg)\n        self.publish_to_unity_joint(msg)\n\n    def odom_callback(self, msg):\n        # Store current state\n        self.current_odom = msg\n\n        # Publish to both environments\n        self.publish_to_gazebo_odom(msg)\n        self.publish_to_unity_odom(msg)\n\n    def publish_to_gazebo_joint(self, joint_state):\n        # Modify message for Gazebo-specific requirements\n        gazebo_msg = JointState()\n        gazebo_msg.header = joint_state.header\n        gazebo_msg.name = joint_state.name\n        gazebo_msg.position = joint_state.position\n        gazebo_msg.velocity = joint_state.velocity\n        gazebo_msg.effort = joint_state.effort\n\n        self.gazebo_joint_pub.publish(gazebo_msg)\n\n    def publish_to_unity_joint(self, joint_state):\n        # Modify message for Unity-specific requirements\n        unity_msg = JointState()\n        unity_msg.header = joint_state.header\n        unity_msg.name = joint_state.name\n        unity_msg.position = joint_state.position\n        unity_msg.velocity = joint_state.velocity\n        unity_msg.effort = joint_state.effort\n\n        self.unity_joint_pub.publish(unity_msg)\n\n    def publish_to_gazebo_odom(self, odom):\n        # Publish to Gazebo\n        self.gazebo_odom_pub.publish(odom)\n\n    def publish_to_unity_odom(self, odom):\n        # Publish to Unity\n        self.unity_odom_pub.publish(odom)\n"})}),"\n",(0,i.jsx)(e.h3,{id:"sensor-data-synchronization",children:"Sensor Data Synchronization"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"from sensor_msgs.msg import LaserScan, Image, Imu\n\nclass SensorSync(Node):\n    def __init__(self):\n        super().__init__('sensor_sync')\n\n        # Publishers for both environments\n        self.gazebo_laser_pub = self.create_publisher(LaserScan, '/gazebo/laser_scan', 10)\n        self.unity_laser_pub = self.create_publisher(LaserScan, '/unity/laser_scan', 10)\n        self.gazebo_camera_pub = self.create_publisher(Image, '/gazebo/camera/image_raw', 10)\n        self.unity_camera_pub = self.create_publisher(Image, '/unity/camera/image_raw', 10)\n\n        # Subscribers for sensor data\n        self.laser_sub = self.create_subscription(LaserScan, '/laser_scan', self.laser_callback, 10)\n        self.camera_sub = self.create_subscription(Image, '/camera/image_raw', self.camera_callback, 10)\n\n    def laser_callback(self, msg):\n        # Publish to both environments\n        self.gazebo_laser_pub.publish(msg)\n        self.unity_laser_pub.publish(msg)\n\n    def camera_callback(self, msg):\n        # Publish to both environments\n        self.gazebo_camera_pub.publish(msg)\n        self.unity_camera_pub.publish(msg)\n"})}),"\n",(0,i.jsx)(e.h2,{id:"gazebo-specific-synchronization",children:"Gazebo-Specific Synchronization"}),"\n",(0,i.jsx)(e.h3,{id:"gazebo-state-publisher",children:"Gazebo State Publisher"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include "rclcpp/rclcpp.hpp"\n#include "sensor_msgs/msg/joint_state.hpp"\n#include "gazebo_msgs/msg/model_states.hpp"\n#include "geometry_msgs/msg/transform_stamped.hpp"\n#include "tf2_ros/transform_broadcaster.h"\n\nclass GazeboStateSync : public rclcpp::Node\n{\npublic:\n    GazeboStateSync() : Node("gazebo_state_sync")\n    {\n        // Publishers\n        joint_pub_ = this->create_publisher<sensor_msgs::msg::JointState>(\n            "/gazebo/joint_states", 10);\n        model_state_pub_ = this->create_publisher<gazebo_msgs::msg::ModelStates>(\n            "/gazebo/model_states", 10);\n\n        // Subscribers\n        joint_sub_ = this->create_subscription<sensor_msgs::msg::JointState>(\n            "/joint_states", 10,\n            std::bind(&GazeboStateSync::joint_callback, this, std::placeholders::_1));\n\n        // TF broadcaster\n        tf_broadcaster_ = std::make_shared<tf2_ros::TransformBroadcaster>(*this);\n    }\n\nprivate:\n    void joint_callback(const sensor_msgs::msg::JointState::SharedPtr msg)\n    {\n        // Forward joint states to Gazebo\n        joint_pub_->publish(*msg);\n\n        // Create and publish model states\n        publish_model_states(msg);\n\n        // Publish transforms\n        publish_transforms(msg);\n    }\n\n    void publish_model_states(const sensor_msgs::msg::JointState::SharedPtr joint_msg)\n    {\n        gazebo_msgs::msg::ModelStates model_states;\n\n        // Convert joint states to model states\n        // This would depend on your specific robot model\n        model_states.name = {"robot_model"};  // Model names\n        model_states.pose = {create_pose_from_joints(joint_msg)};\n        model_states.twist = {create_twist_from_joints(joint_msg)};\n\n        model_state_pub_->publish(model_states);\n    }\n\n    geometry_msgs::msg::Pose create_pose_from_joints(const sensor_msgs::msg::JointState::SharedPtr joint_msg)\n    {\n        // Create pose based on joint configuration\n        geometry_msgs::msg::Pose pose;\n        // Implementation depends on kinematics\n        return pose;\n    }\n\n    rclcpp::Publisher<sensor_msgs::msg::JointState>::SharedPtr joint_pub_;\n    rclcpp::Publisher<gazebo_msgs::msg::ModelStates>::SharedPtr model_state_pub_;\n    rclcpp::Subscription<sensor_msgs::msg::JointState>::SharedPtr joint_sub_;\n    std::shared_ptr<tf2_ros::TransformBroadcaster> tf_broadcaster_;\n};\n'})}),"\n",(0,i.jsx)(e.h2,{id:"unity-specific-synchronization",children:"Unity-Specific Synchronization"}),"\n",(0,i.jsx)(e.h3,{id:"unity-state-synchronization-script",children:"Unity State Synchronization Script"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'using UnityEngine;\nusing Unity.Robotics.ROSTCPConnector;\nusing RosMessageTypes.Sensor;\nusing RosMessageTypes.Nav;\nusing RosMessageTypes.Geometry;\n\npublic class UnityStateSync : MonoBehaviour\n{\n    ROSConnection ros;\n    public GameObject robot;\n    private float lastSyncTime;\n\n    void Start()\n    {\n        ros = ROSConnection.GetOrCreateInstance();\n\n        // Subscribe to state updates from ROS\n        ros.Subscribe<JointStateMsg>("unity/joint_states", OnJointStateUpdate);\n        ros.Subscribe<OdometryMsg>("unity/odom", OnOdomUpdate);\n\n        // Initialize sync time\n        lastSyncTime = Time.time;\n    }\n\n    void OnJointStateUpdate(JointStateMsg jointState)\n    {\n        // Update robot joints in Unity based on received state\n        for (int i = 0; i < jointState.name.Length && i < jointState.position.Length; i++)\n        {\n            UpdateRobotJoint(jointState.name[i], jointState.position[i]);\n        }\n    }\n\n    void OnOdomUpdate(OdometryMsg odom)\n    {\n        // Update robot position and orientation in Unity\n        robot.transform.position = new Vector3(\n            (float)odom.pose.pose.position.x,\n            (float)odom.pose.pose.position.y,\n            (float)odom.pose.pose.position.z\n        );\n\n        robot.transform.rotation = new Quaternion(\n            (float)odom.pose.pose.orientation.x,\n            (float)odom.pose.pose.orientation.y,\n            (float)odom.pose.pose.orientation.z,\n            (float)odom.pose.pose.orientation.w\n        );\n    }\n\n    void UpdateRobotJoint(string jointName, double position)\n    {\n        // Find the joint in the robot hierarchy and update its position\n        Transform joint = robot.transform.Find(jointName);\n        if (joint != null)\n        {\n            // Update joint position based on joint type\n            // For revolute joints: apply rotation\n            // For prismatic joints: apply translation\n            joint.localEulerAngles = new Vector3(0, 0, (float)position * Mathf.Rad2Deg);\n        }\n    }\n\n    void Update()\n    {\n        // Periodically send Unity state back to ROS\n        if (Time.time - lastSyncTime > 0.05f) // 20Hz update\n        {\n            PublishUnityState();\n            lastSyncTime = Time.time;\n        }\n    }\n\n    void PublishUnityState()\n    {\n        // Publish current Unity robot state to ROS\n        var jointState = new JointStateMsg();\n        jointState.header = new std_msgs.HeaderMsg();\n        jointState.header.stamp = new TimeStamp(0, (uint)(Time.time * 1e9));\n        jointState.header.frame_id = "unity_base";\n\n        // Get joint names and positions from Unity robot\n        var jointNames = GetJointNames();\n        var jointPositions = GetJointPositions();\n\n        jointState.name = jointNames;\n        jointState.position = jointPositions;\n\n        ros.Publish("unity/current_joint_states", jointState);\n    }\n\n    string[] GetJointNames()\n    {\n        // Return array of joint names in the robot\n        // This should match the joint names in your URDF\n        return new string[] { "joint1", "joint2", "joint3" };\n    }\n\n    double[] GetJointPositions()\n    {\n        // Return current joint positions from Unity robot\n        // This would involve traversing the robot hierarchy\n        return new double[] { 0.1, 0.2, 0.3 };\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"synchronization-validation",children:"Synchronization Validation"}),"\n",(0,i.jsx)(e.h3,{id:"validation-node",children:"Validation Node"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64MultiArray\nimport numpy as np\n\nclass SyncValidator(Node):\n    def __init__(self):\n        super().__init__('sync_validator')\n\n        # Subscribers for both environments\n        self.gazebo_sub = self.create_subscription(JointState, '/gazebo/joint_states', self.gazebo_callback, 10)\n        self.unity_sub = self.create_subscription(JointState, '/unity/joint_states', self.unity_callback, 10)\n\n        # Publisher for validation results\n        self.validation_pub = self.create_publisher(Float64MultiArray, '/sync_validation', 10)\n\n        # Storage for comparison\n        self.gazebo_state = None\n        self.unity_state = None\n        self.sync_errors = []\n\n    def gazebo_callback(self, msg):\n        self.gazebo_state = msg\n        self.validate_sync()\n\n    def unity_callback(self, msg):\n        self.unity_state = msg\n        self.validate_sync()\n\n    def validate_sync(self):\n        if self.gazebo_state is None or self.unity_state is None:\n            return\n\n        # Compare joint states\n        if len(self.gazebo_state.position) != len(self.unity_state.position):\n            self.get_logger().warn('Joint count mismatch between environments')\n            return\n\n        # Calculate synchronization error\n        errors = []\n        for i in range(len(self.gazebo_state.position)):\n            error = abs(self.gazebo_state.position[i] - self.unity_state.position[i])\n            errors.append(error)\n\n        avg_error = np.mean(errors)\n        max_error = np.max(errors)\n\n        # Log validation results\n        self.get_logger().info(f'Sync validation - Avg error: {avg_error:.4f}, Max error: {max_error:.4f}')\n\n        # Store for trend analysis\n        self.sync_errors.append(avg_error)\n        if len(self.sync_errors) > 100:\n            self.sync_errors.pop(0)\n\n        # Publish validation metrics\n        validation_msg = Float64MultiArray()\n        validation_msg.data = [avg_error, max_error, len(self.sync_errors)]\n        self.validation_pub.publish(validation_msg)\n"})}),"\n",(0,i.jsx)(e.h2,{id:"exercise-tasks",children:"Exercise Tasks"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Create a synchronization node that publishes robot states to both Gazebo and Unity"}),"\n",(0,i.jsx)(e.li,{children:"Implement time synchronization between the environments"}),"\n",(0,i.jsx)(e.li,{children:"Add sensor data synchronization (at least one sensor type)"}),"\n",(0,i.jsx)(e.li,{children:"Create a validation node to measure synchronization accuracy"}),"\n",(0,i.jsx)(e.li,{children:"Test the synchronization with a moving robot"}),"\n",(0,i.jsx)(e.li,{children:"Analyze the synchronization errors and identify improvement areas"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsx)(e.h3,{id:"optimization-strategies",children:"Optimization Strategies"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Use appropriate update rates for different data types"}),"\n",(0,i.jsx)(e.li,{children:"Implement data compression for large messages"}),"\n",(0,i.jsx)(e.li,{children:"Use efficient data structures for state storage"}),"\n",(0,i.jsx)(e.li,{children:"Consider network bandwidth limitations"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"quality-of-service-qos",children:"Quality of Service (QoS)"}),"\n",(0,i.jsx)(e.p,{children:"Configure appropriate QoS settings for different types of data:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Joint states: Reliable delivery with moderate frequency"}),"\n",(0,i.jsx)(e.li,{children:"Sensor data: Best effort with high frequency"}),"\n",(0,i.jsx)(e.li,{children:"Control commands: Reliable delivery with high priority"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,i.jsx)(e.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Time drift"}),": Implement periodic time corrections"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"State desynchronization"}),": Use state validation and correction"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Network delays"}),": Implement predictive synchronization"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Data format mismatches"}),": Standardize message formats"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"In this lab, you learned to synchronize robot states across multiple simulation environments. You implemented time synchronization, state synchronization, and validation mechanisms to ensure consistency between Gazebo and Unity environments."})]})}function d(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(m,{...n})}):m(n)}}}]);