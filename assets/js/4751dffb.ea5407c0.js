"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[8376],{3064(n,e,a){a.r(e),a.d(e,{assets:()=>r,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>t,toc:()=>c});var i=a(4848),s=a(8453);const l={sidebar_label:"Lab 3.1: Isaac Navigation"},o="Lab Exercise 3.1: NVIDIA Isaac Navigation",t={id:"modules/lab-exercises/lab-3-1-isaac-navigation",title:"Lab Exercise 3.1: NVIDIA Isaac Navigation",description:"This lab exercise covers setting up and using NVIDIA Isaac for robot navigation tasks.",source:"@site/docs/modules/lab-exercises/lab-3-1-isaac-navigation.md",sourceDirName:"modules/lab-exercises",slug:"/modules/lab-exercises/lab-3-1-isaac-navigation",permalink:"/hackathon-ai-book/modules/lab-exercises/lab-3-1-isaac-navigation",draft:!1,unlisted:!1,editUrl:"https://github.com/sanilahmed/hackathon-ai-book/tree/main/docs/modules/lab-exercises/lab-3-1-isaac-navigation.md",tags:[],version:"current",frontMatter:{sidebar_label:"Lab 3.1: Isaac Navigation"},sidebar:"tutorialSidebar",previous:{title:"Reinforcement Learning",permalink:"/hackathon-ai-book/modules/ai-robot-brain/reinforcement-learning"},next:{title:"Lab 3.1: Isaac Sim Setup",permalink:"/hackathon-ai-book/modules/lab-exercises/lab-3-1-isaac-sim-setup"}},r={},c=[{value:"Objectives",id:"objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Isaac Navigation Overview",id:"isaac-navigation-overview",level:2},{value:"Installation and Setup",id:"installation-and-setup",level:2},{value:"Isaac ROS Navigation Installation",id:"isaac-ros-navigation-installation",level:3},{value:"Environment Setup",id:"environment-setup",level:3},{value:"Navigation Stack Configuration",id:"navigation-stack-configuration",level:2},{value:"Costmap Configuration",id:"costmap-configuration",level:3},{value:"Local Costmap Configuration",id:"local-costmap-configuration",level:3},{value:"Isaac-Specific Navigation Features",id:"isaac-specific-navigation-features",level:2},{value:"GPU-Accelerated Path Planning",id:"gpu-accelerated-path-planning",level:3},{value:"Visual SLAM Integration",id:"visual-slam-integration",level:3},{value:"Navigation Launch Configuration",id:"navigation-launch-configuration",level:2},{value:"Isaac Navigation Launch File",id:"isaac-navigation-launch-file",level:3},{value:"Testing Navigation",id:"testing-navigation",level:2},{value:"Navigation Test Node",id:"navigation-test-node",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"GPU Memory Management",id:"gpu-memory-management",level:3},{value:"Exercise Tasks",id:"exercise-tasks",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Summary",id:"summary",level:2}];function _(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h1,{id:"lab-exercise-31-nvidia-isaac-navigation",children:"Lab Exercise 3.1: NVIDIA Isaac Navigation"}),"\n",(0,i.jsx)(e.p,{children:"This lab exercise covers setting up and using NVIDIA Isaac for robot navigation tasks."}),"\n",(0,i.jsx)(e.h2,{id:"objectives",children:"Objectives"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Install and configure NVIDIA Isaac navigation stack"}),"\n",(0,i.jsx)(e.li,{children:"Set up costmaps and local/global planners"}),"\n",(0,i.jsx)(e.li,{children:"Implement navigation behaviors"}),"\n",(0,i.jsx)(e.li,{children:"Test navigation in simulation"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"NVIDIA GPU with CUDA support"}),"\n",(0,i.jsx)(e.li,{children:"ROS 2 Humble Hawksbill"}),"\n",(0,i.jsx)(e.li,{children:"Isaac Sim (optional for simulation)"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"isaac-navigation-overview",children:"Isaac Navigation Overview"}),"\n",(0,i.jsx)(e.p,{children:"NVIDIA Isaac Navigation provides:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"GPU-accelerated path planning"}),"\n",(0,i.jsx)(e.li,{children:"Optimized obstacle avoidance"}),"\n",(0,i.jsx)(e.li,{children:"Real-time performance"}),"\n",(0,i.jsx)(e.li,{children:"Integration with Isaac ecosystem"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"installation-and-setup",children:"Installation and Setup"}),"\n",(0,i.jsx)(e.h3,{id:"isaac-ros-navigation-installation",children:"Isaac ROS Navigation Installation"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Install Isaac ROS packages:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"sudo apt update\nsudo apt install ros-humble-isaac-ros-nav2-bringup\nsudo apt install ros-humble-isaac-ros-occupancy-grid-localizer\nsudo apt install ros-humble-isaac-ros-visual-slam\n"})}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Install navigation dependencies:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"sudo apt install ros-humble-navigation2 ros-humble-nav2-bringup\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"environment-setup",children:"Environment Setup"}),"\n",(0,i.jsxs)(e.p,{children:["Add to your ",(0,i.jsx)(e.code,{children:".bashrc"}),":"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"export ISAAC_ROS_WS=/opt/isaac_ros\nexport ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:$ISAAC_ROS_WS\n"})}),"\n",(0,i.jsx)(e.h2,{id:"navigation-stack-configuration",children:"Navigation Stack Configuration"}),"\n",(0,i.jsx)(e.h3,{id:"costmap-configuration",children:"Costmap Configuration"}),"\n",(0,i.jsxs)(e.p,{children:["Create ",(0,i.jsx)(e.code,{children:"costmap_params.yaml"}),":"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:'amcl:\n  ros__parameters:\n    use_sim_time: True\n    alpha1: 0.2\n    alpha2: 0.2\n    alpha3: 0.2\n    alpha4: 0.2\n    alpha5: 0.2\n    base_frame_id: "base_footprint"\n    beam_skip_distance: 0.5\n    beam_skip_error_threshold: 0.9\n    beam_skip_threshold: 0.3\n    do_beamskip: false\n    global_frame_id: "map"\n    lambda_short: 0.1\n    laser_likelihood_max_dist: 2.0\n    laser_max_range: 100.0\n    laser_min_range: -1.0\n    max_beams: 60\n    max_particles: 2000\n    min_particles: 500\n    odom_frame_id: "odom"\n    pf_err: 0.05\n    pf_z: 0.99\n    recovery_alpha_fast: 0.0\n    recovery_alpha_slow: 0.0\n    resample_interval: 1\n    robot_model_type: "nav2_amcl::DifferentialMotionModel"\n    save_pose_delay: 0.5\n    save_pose_rate: 0.5\n    sigma_hit: 0.2\n    tf_broadcast: true\n    transform_tolerance: 1.0\n    update_min_a: 0.2\n    update_min_d: 0.25\n    z_hit: 0.5\n    z_max: 0.05\n    z_rand: 0.5\n    z_short: 0.05\n\namcl_map_client:\n  ros__parameters:\n    use_sim_time: True\n\namcl_rclcpp_node:\n  ros__parameters:\n    use_sim_time: True\n\nbt_navigator:\n  ros__parameters:\n    use_sim_time: True\n    global_frame: map\n    robot_base_frame: base_link\n    odom_topic: /odom\n    bt_loop_duration: 10\n    default_server_timeout: 20\n    enable_groot_monitoring: True\n    groot_zmq_publisher_port: 1666\n    groot_zmq_server_port: 1667\n    # Specify the path to the Behavior Tree XML file\n    bt_xml_filename: "navigate_w_replanning_and_recovery.xml"\n    # \'default_nav_through_poses_bt_xml\' and \'default_nav_to_pose_bt_xml\' are set automatically based on \'bt_xml_filename\'\n    # Rate limits the frequency of calling the next command\n    navigators: ["navigate_to_pose", "navigate_through_poses"]\n    navigate_to_pose: ["navigation"]\n    navigate_through_poses: ["navigation"]\n    navigation: ["RateController", "GoalChecker", "Controller", "GoalReacher", "Recovery", "GoalChecker"]\n    GoalReacher:\n      plugin: "nav2_navfn_planner/NavfnPlanner"\n      costmap_topic: "local_costmap/costmap_raw"\n      footprint_topic: "local_costmap/published_footprint"\n      goal_checker: "goal_checker"\n      replanner: "recovery"\n    RateController:\n      plugin: "nav2_regulated_pure_pursuit_controller/RegulatedPurePursuitController"\n      speed_topic: "cmd_vel"\n    Recovery:\n      plugin: "nav2_recoveries/RecoveryServer"\n      costmap_topic: "local_costmap/costmap_raw"\n      footprint_topic: "local_costmap/published_footprint"\n    GoalChecker:\n      plugin: "nav2_controller::SimpleGoalChecker"\n      costmap_topic: "local_costmap/costmap_raw"\n      footprint_topic: "local_costmap/published_footprint"\n'})}),"\n",(0,i.jsx)(e.h3,{id:"local-costmap-configuration",children:"Local Costmap Configuration"}),"\n",(0,i.jsxs)(e.p,{children:["Create ",(0,i.jsx)(e.code,{children:"local_costmap_params.yaml"}),":"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:'local_costmap:\n  ros__parameters:\n    update_frequency: 10.0\n    publish_frequency: 10.0\n    global_frame: odom\n    robot_base_frame: base_link\n    use_sim_time: true\n    rolling_window: true\n    width: 3\n    height: 3\n    resolution: 0.05\n    robot_radius: 0.22\n    plugins: ["voxel_layer", "inflation_layer"]\n    inflation_layer:\n      plugin: "nav2_costmap_2d::InflationLayer"\n      cost_scaling_factor: 3.0\n      inflation_radius: 0.55\n    voxel_layer:\n      plugin: "nav2_costmap_2d::VoxelLayer"\n      enabled: True\n      publish_voxel_map: True\n      origin_z: 0.0\n      z_resolution: 0.05\n      z_voxels: 16\n      max_obstacle_height: 2.0\n      mark_threshold: 0\n      observation_sources: scan\n      scan:\n        topic: /scan\n        max_obstacle_height: 2.0\n        clearing: True\n        marking: True\n        data_type: "LaserScan"\n        raytrace_max_range: 3.0\n        raytrace_min_range: 0.0\n        obstacle_max_range: 2.5\n        obstacle_min_range: 0.0\n'})}),"\n",(0,i.jsx)(e.h2,{id:"isaac-specific-navigation-features",children:"Isaac-Specific Navigation Features"}),"\n",(0,i.jsx)(e.h3,{id:"gpu-accelerated-path-planning",children:"GPU-Accelerated Path Planning"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom nav_msgs.msg import Path\nfrom geometry_msgs.msg import PoseStamped\nimport numpy as np\n\nclass IsaacPathPlanner(Node):\n    def __init__(self):\n        super().__init__('isaac_path_planner')\n\n        # Publisher for planned path\n        self.path_pub = self.create_publisher(Path, 'global_plan', 10)\n\n        # Subscriber for goal poses\n        self.goal_sub = self.create_subscription(\n            PoseStamped, 'goal_pose', self.goal_callback, 10\n        )\n\n        # Initialize GPU-accelerated planner (simulated)\n        self.gpu_planner_initialized = self.initialize_gpu_planner()\n\n    def initialize_gpu_planner(self):\n        # This would initialize NVIDIA's GPU-accelerated planning\n        # For simulation purposes, return True\n        self.get_logger().info('GPU-accelerated path planner initialized')\n        return True\n\n    def goal_callback(self, goal_msg):\n        if self.gpu_planner_initialized:\n            # Plan path using GPU acceleration\n            path = self.plan_path_gpu(goal_msg)\n            self.path_pub.publish(path)\n\n    def plan_path_gpu(self, goal_msg):\n        # Simulate GPU-accelerated path planning\n        # In real implementation, this would use Isaac's GPU planners\n        path_msg = Path()\n        path_msg.header.frame_id = \"map\"\n        path_msg.header.stamp = self.get_clock().now().to_msg()\n\n        # Create a simple path (in real implementation, this would be the result of GPU planning)\n        start_x, start_y = 0.0, 0.0\n        goal_x, goal_y = goal_msg.pose.position.x, goal_msg.pose.position.y\n\n        # Generate intermediate poses\n        steps = 20\n        for i in range(steps + 1):\n            t = i / steps\n            x = start_x + t * (goal_x - start_x)\n            y = start_y + t * (goal_y - start_y)\n\n            pose = PoseStamped()\n            pose.header.frame_id = \"map\"\n            pose.pose.position.x = x\n            pose.pose.position.y = y\n            pose.pose.position.z = 0.0\n            pose.pose.orientation.w = 1.0\n\n            path_msg.poses.append(pose)\n\n        return path_msg\n"})}),"\n",(0,i.jsx)(e.h3,{id:"visual-slam-integration",children:"Visual SLAM Integration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"class IsaacVisualSLAM(Node):\n    def __init__(self):\n        super().__init__('isaac_visual_slam')\n\n        # Publishers and subscribers\n        self.odom_pub = self.create_publisher(Odometry, 'visual_odom', 10)\n        self.map_pub = self.create_publisher(OccupancyGrid, 'visual_map', 10)\n\n        # Camera subscriber\n        self.image_sub = self.create_subscription(\n            Image, 'camera/image_raw', self.image_callback, 10\n        )\n\n        # Initialize Isaac Visual SLAM\n        self.slam_initialized = self.initialize_visual_slam()\n\n    def initialize_visual_slam(self):\n        # Initialize Isaac's visual SLAM pipeline\n        # This would typically involve CUDA initialization\n        self.get_logger().info('Isaac Visual SLAM initialized')\n        return True\n\n    def image_callback(self, image_msg):\n        if self.slam_initialized:\n            # Process image for visual SLAM\n            self.process_visual_slam(image_msg)\n\n    def process_visual_slam(self, image_msg):\n        # Process image for pose estimation and map building\n        # This would use Isaac's GPU-accelerated visual SLAM\n        pass\n"})}),"\n",(0,i.jsx)(e.h2,{id:"navigation-launch-configuration",children:"Navigation Launch Configuration"}),"\n",(0,i.jsx)(e.h3,{id:"isaac-navigation-launch-file",children:"Isaac Navigation Launch File"}),"\n",(0,i.jsxs)(e.p,{children:["Create ",(0,i.jsx)(e.code,{children:"isaac_navigation.launch.py"}),":"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    # Declare launch arguments\n    use_sim_time = LaunchConfiguration('use_sim_time')\n    map_yaml_file = LaunchConfiguration('map')\n\n    # Navigation launch\n    navigation_launch = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('isaac_ros_nav2_bringup'),\n                'launch',\n                'navigation.launch.py'\n            ])\n        ]),\n        launch_arguments={\n            'use_sim_time': use_sim_time\n        }.items()\n    )\n\n    # SLAM node\n    visual_slam_node = Node(\n        package='isaac_ros_visual_slam',\n        executable='visual_slam_node',\n        name='visual_slam',\n        parameters=[{\n            'use_sim_time': use_sim_time,\n            'enable_rectified_pose': True,\n            'map_frame': 'map',\n            'odom_frame': 'odom',\n            'base_frame': 'base_link',\n            'enable_fisheye': False,\n            'input_width': 1920,\n            'input_height': 1080,\n            'publish_odom_tf': True\n        }],\n        remappings=[\n            ('/visual_slam/image_raw', '/camera/image_raw'),\n            ('/visual_slam/camera_info', '/camera/camera_info')\n        ]\n    )\n\n    return LaunchDescription([\n        DeclareLaunchArgument(\n            'use_sim_time',\n            default_value='false',\n            description='Use simulation time if true'\n        ),\n        DeclareLaunchArgument(\n            'map',\n            default_value='',\n            description='Full path to map file to load'\n        ),\n        navigation_launch,\n        visual_slam_node\n    ])\n"})}),"\n",(0,i.jsx)(e.h2,{id:"testing-navigation",children:"Testing Navigation"}),"\n",(0,i.jsx)(e.h3,{id:"navigation-test-node",children:"Navigation Test Node"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped\nfrom action_msgs.msg import GoalStatus\nfrom nav2_msgs.action import NavigateToPose\nfrom rclpy.action import ActionClient\n\nclass NavigationTest(Node):\n    def __init__(self):\n        super().__init__('navigation_test')\n\n        # Action client for navigation\n        self.nav_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')\n\n        # Timer to send navigation goals\n        self.timer = self.create_timer(10.0, self.send_navigation_goal)\n\n    def send_navigation_goal(self):\n        # Wait for action server\n        if not self.nav_client.wait_for_server(timeout_sec=5.0):\n            self.get_logger().error('Navigation action server not available')\n            return\n\n        # Create navigation goal\n        goal_msg = NavigateToPose.Goal()\n        goal_msg.pose.header.frame_id = 'map'\n        goal_msg.pose.pose.position.x = 2.0\n        goal_msg.pose.pose.position.y = 2.0\n        goal_msg.pose.pose.orientation.w = 1.0\n\n        # Send goal\n        self.nav_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback\n        ).add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info('Goal rejected')\n            return\n\n        self.get_logger().info('Goal accepted')\n        goal_handle.get_result_async().add_done_callback(self.get_result_callback)\n\n    def feedback_callback(self, feedback_msg):\n        self.get_logger().info(f'Navigation progress: {feedback_msg.feedback.distance_remaining:.2f}m remaining')\n\n    def get_result_callback(self, future):\n        result = future.result().result\n        status = future.result().status\n        if status == GoalStatus.STATUS_SUCCEEDED:\n            self.get_logger().info('Navigation succeeded!')\n        else:\n            self.get_logger().info(f'Navigation failed with status: {status}')\n"})}),"\n",(0,i.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,i.jsx)(e.h3,{id:"gpu-memory-management",children:"GPU Memory Management"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"class IsaacNavigationOptimizer:\n    def __init__(self):\n        self.gpu_memory_limit = 0.8  # Use 80% of available GPU memory\n        self.plan_cache_size = 10    # Cache recent plans\n\n    def optimize_gpu_usage(self):\n        # Monitor GPU memory usage\n        # Adjust planning parameters based on available memory\n        # Implement plan caching to reduce repeated computation\n        pass\n"})}),"\n",(0,i.jsx)(e.h2,{id:"exercise-tasks",children:"Exercise Tasks"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Install Isaac ROS navigation packages"}),"\n",(0,i.jsx)(e.li,{children:"Configure costmaps and planners for your robot"}),"\n",(0,i.jsx)(e.li,{children:"Implement a simple path planner using Isaac's GPU acceleration (simulated)"}),"\n",(0,i.jsx)(e.li,{children:"Create a launch file for Isaac navigation"}),"\n",(0,i.jsx)(e.li,{children:"Test navigation in simulation or with a real robot"}),"\n",(0,i.jsx)(e.li,{children:"Measure and optimize navigation performance"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,i.jsx)(e.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"GPU initialization failures"}),": Check CUDA installation and GPU drivers"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Navigation timeouts"}),": Verify sensor data and costmap configuration"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Performance issues"}),": Monitor GPU utilization and memory usage"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Map building problems"}),": Check camera calibration and visual features"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"In this lab, you learned to set up and use NVIDIA Isaac for robot navigation. You configured the navigation stack, implemented GPU-accelerated planning, and tested navigation performance. Isaac's GPU acceleration provides significant performance improvements for complex navigation tasks."})]})}function p(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(_,{...n})}):_(n)}},8453(n,e,a){a.d(e,{R:()=>o,x:()=>t});var i=a(6540);const s={},l=i.createContext(s);function o(n){const e=i.useContext(l);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function t(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),i.createElement(l.Provider,{value:e},n.children)}}}]);