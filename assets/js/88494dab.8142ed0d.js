"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[5823],{5595(n,e,t){t.r(e),t.d(e,{assets:()=>i,contentTitle:()=>s,default:()=>_,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var o=t(4848),r=t(8453);const a={sidebar_label:"Lab 3.3: Planning and Control"},s="Lab Exercise 3.3: Planning and Control in AI-Robot Brain",l={id:"modules/lab-exercises/lab-3-3-planning-control",title:"Lab Exercise 3.3: Planning and Control in AI-Robot Brain",description:"This lab exercise covers implementing planning and control systems for robot AI using NVIDIA Isaac.",source:"@site/docs/modules/lab-exercises/lab-3-3-planning-control.md",sourceDirName:"modules/lab-exercises",slug:"/modules/lab-exercises/lab-3-3-planning-control",permalink:"/hackathon-ai-book/modules/lab-exercises/lab-3-3-planning-control",draft:!1,unlisted:!1,editUrl:"https://github.com/sanilahmed/hackathon-ai-book/tree/main/docs/modules/lab-exercises/lab-3-3-planning-control.md",tags:[],version:"current",frontMatter:{sidebar_label:"Lab 3.3: Planning and Control"},sidebar:"tutorialSidebar",previous:{title:"Lab 3.2: Perception Systems",permalink:"/hackathon-ai-book/modules/lab-exercises/lab-3-2-perception-systems"},next:{title:"Lab 3.4: Reinforcement Learning",permalink:"/hackathon-ai-book/modules/lab-exercises/lab-3-4-reinforcement-learning"}},i={},c=[{value:"Objectives",id:"objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Planning System Overview",id:"planning-system-overview",level:2},{value:"Path Planning vs. Motion Planning",id:"path-planning-vs-motion-planning",level:3},{value:"Planning Architecture",id:"planning-architecture",level:3},{value:"Global Path Planning",id:"global-path-planning",level:2},{value:"A* Path Planner Implementation",id:"a-path-planner-implementation",level:3},{value:"Local Path Planning and Trajectory Generation",id:"local-path-planning-and-trajectory-generation",level:2},{value:"Dynamic Window Approach (DWA)",id:"dynamic-window-approach-dwa",level:3},{value:"Control Systems",id:"control-systems",level:2},{value:"PID Controller Implementation",id:"pid-controller-implementation",level:3},{value:"Pure Pursuit Controller",id:"pure-pursuit-controller",level:3},{value:"Isaac-Specific Planning and Control",id:"isaac-specific-planning-and-control",level:2},{value:"Isaac Manipulation Planning",id:"isaac-manipulation-planning",level:3},{value:"Model Predictive Control (MPC)",id:"model-predictive-control-mpc",level:2},{value:"Linear MPC Implementation",id:"linear-mpc-implementation",level:3},{value:"Planning and Control Integration Node",id:"planning-and-control-integration-node",level:2},{value:"Exercise Tasks",id:"exercise-tasks",level:2},{value:"Performance Evaluation",id:"performance-evaluation",level:2},{value:"Control Performance Metrics",id:"control-performance-metrics",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Summary",id:"summary",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h1,{id:"lab-exercise-33-planning-and-control-in-ai-robot-brain",children:"Lab Exercise 3.3: Planning and Control in AI-Robot Brain"}),"\n",(0,o.jsx)(e.p,{children:"This lab exercise covers implementing planning and control systems for robot AI using NVIDIA Isaac."}),"\n",(0,o.jsx)(e.h2,{id:"objectives",children:"Objectives"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Implement path planning algorithms"}),"\n",(0,o.jsx)(e.li,{children:"Create motion control systems"}),"\n",(0,o.jsx)(e.li,{children:"Integrate planning with perception"}),"\n",(0,o.jsx)(e.li,{children:"Test control performance in simulation"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"ROS 2 Humble with navigation packages"}),"\n",(0,o.jsx)(e.li,{children:"Isaac Sim environment"}),"\n",(0,o.jsx)(e.li,{children:"Basic knowledge of control theory"}),"\n",(0,o.jsx)(e.li,{children:"Completed perception systems lab"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"planning-system-overview",children:"Planning System Overview"}),"\n",(0,o.jsx)(e.h3,{id:"path-planning-vs-motion-planning",children:"Path Planning vs. Motion Planning"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Path Planning"}),": Find collision-free path from start to goal"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Motion Planning"}),": Find dynamically feasible trajectory considering robot dynamics"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"planning-architecture",children:"Planning Architecture"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"Goal \u2192 Global Planner \u2192 Local Planner \u2192 Controller \u2192 Robot\n"})}),"\n",(0,o.jsx)(e.h2,{id:"global-path-planning",children:"Global Path Planning"}),"\n",(0,o.jsx)(e.h3,{id:"a-path-planner-implementation",children:"A* Path Planner Implementation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom nav_msgs.msg import OccupancyGrid, Path\nfrom geometry_msgs.msg import PoseStamped, Point\nfrom visualization_msgs.msg import Marker\nimport numpy as np\nimport heapq\nfrom math import sqrt\n\nclass AStarPlanner(Node):\n    def __init__(self):\n        super().__init__('astar_planner')\n\n        # Publishers and subscribers\n        self.map_sub = self.create_subscription(\n            OccupancyGrid, '/map', self.map_callback, 10\n        )\n        self.path_pub = self.create_publisher(Path, '/global_plan', 10)\n        self.marker_pub = self.create_publisher(Marker, '/path_marker', 10)\n\n        # Storage\n        self.map_data = None\n        self.map_resolution = 0.0\n        self.map_origin = [0.0, 0.0]\n\n    def map_callback(self, msg):\n        self.map_data = np.array(msg.data).reshape((msg.info.height, msg.info.width))\n        self.map_resolution = msg.info.resolution\n        self.map_origin = [msg.info.origin.position.x, msg.info.origin.position.y]\n\n    def plan_path(self, start, goal):\n        if self.map_data is None:\n            return None\n\n        # Convert world coordinates to map indices\n        start_idx = self.world_to_map(start)\n        goal_idx = self.world_to_map(goal)\n\n        # Run A* algorithm\n        path_indices = self.astar(start_idx, goal_idx)\n\n        if path_indices:\n            # Convert back to world coordinates\n            path = []\n            for idx in path_indices:\n                world_pos = self.map_to_world(idx)\n                pose = PoseStamped()\n                pose.pose.position.x = world_pos[0]\n                pose.pose.position.y = world_pos[1]\n                pose.pose.position.z = 0.0\n                path.append(pose)\n\n            return path\n\n        return None\n\n    def astar(self, start, goal):\n        # A* algorithm implementation\n        open_set = [(0, start)]\n        came_from = {}\n        g_score = {start: 0}\n        f_score = {start: self.heuristic(start, goal)}\n\n        while open_set:\n            current = heapq.heappop(open_set)[1]\n\n            if current == goal:\n                # Reconstruct path\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                return path[::-1]\n\n            for neighbor in self.get_neighbors(current):\n                tentative_g_score = g_score[current] + self.distance(current, neighbor)\n\n                if tentative_g_score < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + self.heuristic(neighbor, goal)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n        return None  # No path found\n\n    def heuristic(self, a, b):\n        # Euclidean distance heuristic\n        return sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)\n\n    def get_neighbors(self, pos):\n        neighbors = []\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                new_pos = (pos[0] + dx, pos[1] + dy)\n\n                # Check bounds\n                if (0 <= new_pos[0] < self.map_data.shape[1] and\n                    0 <= new_pos[1] < self.map_data.shape[0]):\n\n                    # Check if cell is free (value < 50 in occupancy grid)\n                    if self.map_data[new_pos[1], new_pos[0]] < 50:\n                        neighbors.append(new_pos)\n\n        return neighbors\n\n    def distance(self, a, b):\n        return sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)\n\n    def world_to_map(self, world_pos):\n        map_x = int((world_pos[0] - self.map_origin[0]) / self.map_resolution)\n        map_y = int((world_pos[1] - self.map_origin[1]) / self.map_resolution)\n        return (map_x, map_y)\n\n    def map_to_world(self, map_idx):\n        world_x = map_idx[0] * self.map_resolution + self.map_origin[0]\n        world_y = map_idx[1] * self.map_resolution + self.map_origin[1]\n        return [world_x, world_y]\n"})}),"\n",(0,o.jsx)(e.h2,{id:"local-path-planning-and-trajectory-generation",children:"Local Path Planning and Trajectory Generation"}),"\n",(0,o.jsx)(e.h3,{id:"dynamic-window-approach-dwa",children:"Dynamic Window Approach (DWA)"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist, PoseWithCovarianceStamped\nfrom sensor_msgs.msg import LaserScan\nfrom tf2_ros import TransformListener, Buffer\nfrom nav_msgs.msg import Path\nimport numpy as np\n\nclass DWALocalPlanner(Node):\n    def __init__(self):\n        super().__init__('dwa_local_planner')\n\n        # Publishers and subscribers\n        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)\n        self.scan_sub = self.create_subscription(LaserScan, '/scan', self.scan_callback, 10)\n        self.path_sub = self.create_subscription(Path, '/global_plan', self.path_callback, 10)\n        self.pose_sub = self.create_subscription(\n            PoseWithCovarianceStamped, '/amcl_pose', self.pose_callback, 10\n        )\n\n        # TF listener for robot pose\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n\n        # Robot parameters\n        self.max_speed = 0.5  # m/s\n        self.max_yaw_rate = 1.0  # rad/s\n        self.max_accel = 0.5  # m/s^2\n        self.max_delta_yaw_rate = 3.2  # rad/s^2\n\n        # DWA parameters\n        self.predict_time = 3.0  # s\n        self.to_goal_cost_gain = 0.15\n        self.speed_cost_gain = 1.0\n        self.obstacle_cost_gain = 1.0\n\n        # Storage\n        self.laser_data = None\n        self.global_path = None\n        self.current_pose = None\n        self.current_velocity = [0.0, 0.0]  # [linear, angular]\n\n        # Timer for control loop\n        self.control_timer = self.create_timer(0.1, self.control_loop)\n\n    def scan_callback(self, msg):\n        self.laser_data = msg\n\n    def path_callback(self, msg):\n        self.global_path = msg.poses\n\n    def pose_callback(self, msg):\n        self.current_pose = msg.pose.pose\n\n    def control_loop(self):\n        if (self.current_pose is None or\n            self.global_path is None or\n            self.laser_data is None):\n            return\n\n        # Get robot state\n        robot_pos = [self.current_pose.position.x, self.current_pose.position.y]\n        robot_yaw = self.get_yaw_from_quaternion(self.current_pose.orientation)\n\n        # Get goal from global path\n        goal = self.get_next_waypoint(robot_pos)\n\n        if goal is None:\n            # Stop robot if no goal\n            cmd_vel = Twist()\n            self.cmd_vel_pub.publish(cmd_vel)\n            return\n\n        # Run DWA\n        best_u = self.dwa_control(robot_pos, robot_yaw, goal)\n\n        if best_u is not None:\n            cmd_vel = Twist()\n            cmd_vel.linear.x = best_u[0]\n            cmd_vel.angular.z = best_u[1]\n            self.cmd_vel_pub.publish(cmd_vel)\n\n    def dwa_control(self, robot_pos, robot_yaw, goal):\n        # Calculate dynamic window\n        vs = self.calc_dynamic_window()\n\n        # Evaluate trajectories\n        best_u = None\n        min_score = float('inf')\n\n        for v in np.arange(vs[0], vs[1], 0.1):  # Linear velocity\n            for yaw_rate in np.arange(vs[2], vs[3], 0.1):  # Angular velocity\n                trajectory = self.predict_trajectory(v, yaw_rate, robot_pos, robot_yaw)\n\n                # Calculate costs\n                to_goal_cost = self.calc_to_goal_cost(trajectory, goal)\n                speed_cost = self.calc_speed_cost(trajectory)\n                obstacle_cost = self.calc_obstacle_cost(trajectory)\n\n                # Weighted sum of costs\n                final_cost = (self.to_goal_cost_gain * to_goal_cost +\n                             self.speed_cost_gain * speed_cost +\n                             self.obstacle_cost_gain * obstacle_cost)\n\n                if final_cost < min_score:\n                    min_score = final_cost\n                    best_u = [v, yaw_rate]\n\n        return best_u\n\n    def calc_dynamic_window(self):\n        # Calculate dynamic window based on current velocity and limits\n        vs = [0, self.max_speed, -self.max_yaw_rate, self.max_yaw_rate]\n\n        vd = [self.current_velocity[0] - self.max_accel * 0.1,\n              self.current_velocity[0] + self.max_accel * 0.1,\n              self.current_velocity[1] - self.max_delta_yaw_rate * 0.1,\n              self.current_velocity[1] + self.max_delta_yaw_rate * 0.1]\n\n        # Clamp to dynamic window\n        dw = [max(vs[0], vd[0]), min(vs[1], vd[1]),\n              max(vs[2], vd[2]), min(vs[3], vd[3])]\n\n        return dw\n\n    def predict_trajectory(self, v, yaw_rate, robot_pos, robot_yaw):\n        trajectory = []\n        time = 0\n\n        while time <= self.predict_time:\n            new_x = robot_pos[0] + v * np.cos(robot_yaw) * time\n            new_y = robot_pos[1] + v * np.sin(robot_yaw) * time\n            new_yaw = robot_yaw + yaw_rate * time\n\n            trajectory.append([new_x, new_y, new_yaw])\n            time += 0.1\n\n        return trajectory\n\n    def calc_to_goal_cost(self, trajectory, goal):\n        # Calculate distance to goal from end of trajectory\n        dx = goal[0] - trajectory[-1][0]\n        dy = goal[1] - trajectory[-1][1]\n        error_angle = np.arctan2(dy, dx)\n        cost = abs(error_angle - trajectory[-1][2])\n        return cost\n\n    def calc_speed_cost(self, trajectory):\n        # Calculate cost based on speed (prefer higher speeds)\n        speed = abs(trajectory[0][0])  # Simplified\n        max_speed_cost = abs(self.max_speed)\n        return max_speed_cost - speed\n\n    def calc_obstacle_cost(self, trajectory):\n        # Calculate cost based on obstacle proximity\n        min_dist = float('inf')\n\n        for point in trajectory:\n            for i, range_val in enumerate(self.laser_data.ranges):\n                if not np.isnan(range_val) and range_val < min_dist:\n                    min_dist = range_val\n\n        return 1.0 / min_dist if min_dist != 0 else float('inf')\n\n    def get_yaw_from_quaternion(self, quat):\n        # Convert quaternion to yaw angle\n        siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)\n        cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)\n        return np.arctan2(siny_cosp, cosy_cosp)\n\n    def get_next_waypoint(self, robot_pos):\n        # Find the next waypoint in the global path\n        if not self.global_path:\n            return None\n\n        # Simple approach: find closest point and return the next one\n        min_dist = float('inf')\n        closest_idx = 0\n\n        for i, pose in enumerate(self.global_path):\n            dist = np.sqrt((pose.pose.position.x - robot_pos[0])**2 +\n                          (pose.pose.position.y - robot_pos[1])**2)\n            if dist < min_dist:\n                min_dist = dist\n                closest_idx = i\n\n        # Return next waypoint\n        next_idx = min(closest_idx + 5, len(self.global_path) - 1)  # Look ahead\n        next_waypoint = self.global_path[next_idx]\n\n        return [next_waypoint.pose.position.x, next_waypoint.pose.position.y]\n"})}),"\n",(0,o.jsx)(e.h2,{id:"control-systems",children:"Control Systems"}),"\n",(0,o.jsx)(e.h3,{id:"pid-controller-implementation",children:"PID Controller Implementation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"class PIDController:\n    def __init__(self, kp=1.0, ki=0.0, kd=0.0):\n        self.kp = kp  # Proportional gain\n        self.ki = ki  # Integral gain\n        self.kd = kd  # Derivative gain\n\n        self.prev_error = 0.0\n        self.integral = 0.0\n        self.prev_time = None\n\n    def compute(self, setpoint, measured_value, dt=None):\n        current_time = time.time()\n\n        if self.prev_time is None:\n            self.prev_time = current_time\n\n        if dt is None:\n            dt = current_time - self.prev_time\n\n        if dt <= 0:\n            return 0.0\n\n        # Calculate error\n        error = setpoint - measured_value\n\n        # Proportional term\n        p_term = self.kp * error\n\n        # Integral term\n        self.integral += error * dt\n        i_term = self.ki * self.integral\n\n        # Derivative term\n        derivative = (error - self.prev_error) / dt\n        d_term = self.kd * derivative\n\n        # Calculate output\n        output = p_term + i_term + d_term\n\n        # Store values for next iteration\n        self.prev_error = error\n        self.prev_time = current_time\n\n        return output\n\n    def reset(self):\n        self.prev_error = 0.0\n        self.integral = 0.0\n        self.prev_time = None\n"})}),"\n",(0,o.jsx)(e.h3,{id:"pure-pursuit-controller",children:"Pure Pursuit Controller"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"import math\n\nclass PurePursuitController:\n    def __init__(self, lookahead_distance=1.0):\n        self.lookahead_distance = lookahead_distance\n\n    def calculate_control(self, robot_pos, robot_yaw, path):\n        # Find the look-ahead point on the path\n        look_ahead_point = self.find_look_ahead_point(robot_pos, path)\n\n        if look_ahead_point is None:\n            return 0.0, 0.0  # No control if no point found\n\n        # Calculate the angle to the look-ahead point\n        alpha = math.atan2(\n            look_ahead_point[1] - robot_pos[1],\n            look_ahead_point[0] - robot_pos[0]\n        ) - robot_yaw\n\n        # Calculate curvature\n        curvature = 2 * math.sin(alpha) / self.lookahead_distance\n\n        # Calculate angular velocity (assuming constant linear velocity)\n        linear_vel = 0.3  # m/s\n        angular_vel = linear_vel * curvature\n\n        return linear_vel, angular_vel\n\n    def find_look_ahead_point(self, robot_pos, path):\n        for point in path:\n            dist = math.sqrt(\n                (point[0] - robot_pos[0])**2 +\n                (point[1] - robot_pos[1])**2\n            )\n            if dist >= self.lookahead_distance:\n                return [point[0], point[1]]\n\n        # If no point is far enough, return the last point\n        if path:\n            return [path[-1][0], path[-1][1]]\n\n        return None\n"})}),"\n",(0,o.jsx)(e.h2,{id:"isaac-specific-planning-and-control",children:"Isaac-Specific Planning and Control"}),"\n",(0,o.jsx)(e.h3,{id:"isaac-manipulation-planning",children:"Isaac Manipulation Planning"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import omni\nfrom omni.isaac.core import World\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\nfrom omni.isaac.franka import Franka\nfrom omni.isaac.core.objects import DynamicCuboid\nimport numpy as np\n\nclass IsaacManipulationController:\n    def __init__(self):\n        self.world = World(stage_units_in_meters=1.0)\n        self.robot = None\n        self.object = None\n\n    def setup_environment(self):\n        # Add Franka robot\n        self.robot = self.world.scene.add(\n            Franka(prim_path="/World/Franka", name="franka", position=np.array([0, 0, 0]))\n        )\n\n        # Add object to manipulate\n        self.object = self.world.scene.add(\n            DynamicCuboid(\n                prim_path="/World/Object",\n                name="object",\n                position=np.array([0.5, 0, 0.1]),\n                size=0.1,\n                color=np.array([0.8, 0.1, 0.1])\n            )\n        )\n\n    def plan_manipulation(self, target_position):\n        # Simple manipulation planning (in practice, use MoveIt or similar)\n        # This would involve inverse kinematics and trajectory planning\n\n        # Get current end-effector pose\n        ee_position = self.robot.get_end_effector_frame()[:3, 3]\n\n        # Calculate path to target\n        path = self.interpolate_path(ee_position, target_position)\n\n        return path\n\n    def interpolate_path(self, start, end, steps=10):\n        path = []\n        for i in range(steps + 1):\n            t = i / steps\n            pos = start + t * (end - start)\n            path.append(pos)\n        return path\n\n    def execute_manipulation(self, target_position):\n        self.world.play()\n\n        # Plan path\n        path = self.plan_manipulation(target_position)\n\n        # Execute path following\n        for i in range(1000):  # Simulation steps\n            if i < len(path):\n                target_pos = path[i] if i < len(path) else path[-1]\n\n                # Simple position control (in practice, use proper IK)\n                joint_positions = self.calculate_ik(target_pos)\n                self.robot.set_joint_positions(joint_positions)\n\n            self.world.step(render=True)\n\n        self.world.stop()\n\n    def calculate_ik(self, target_position):\n        # Simplified inverse kinematics\n        # In practice, use Isaac\'s IK solvers or MoveIt\n        return np.zeros(7)  # Placeholder\n'})}),"\n",(0,o.jsx)(e.h2,{id:"model-predictive-control-mpc",children:"Model Predictive Control (MPC)"}),"\n",(0,o.jsx)(e.h3,{id:"linear-mpc-implementation",children:"Linear MPC Implementation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"import numpy as np\nfrom scipy.optimize import minimize\n\nclass LinearMPC:\n    def __init__(self, A, B, Q, R, horizon=10):\n        self.A = A  # State transition matrix\n        self.B = B  # Control input matrix\n        self.Q = Q  # State cost matrix\n        self.R = R  # Control cost matrix\n        self.horizon = horizon\n\n    def solve(self, current_state, reference_trajectory):\n        def cost_function(u_flat):\n            # Reshape control sequence\n            U = u_flat.reshape((self.horizon, -1))\n\n            total_cost = 0\n            state = current_state.copy()\n\n            for k in range(self.horizon):\n                # Predict next state\n                state = self.A @ state + self.B @ U[k]\n\n                # Calculate cost\n                if k < len(reference_trajectory):\n                    error = state - reference_trajectory[k]\n                else:\n                    error = state - reference_trajectory[-1]\n\n                stage_cost = error.T @ self.Q @ error + U[k].T @ self.R @ U[k]\n                total_cost += stage_cost\n\n            return total_cost\n\n        # Initial guess\n        u_init = np.zeros(self.horizon * self.B.shape[1])\n\n        # Solve optimization problem\n        result = minimize(cost_function, u_init, method='SLSQP')\n\n        if result.success:\n            U_opt = result.x.reshape((self.horizon, -1))\n            return U_opt[0]  # Return first control input\n        else:\n            return np.zeros(self.B.shape[1])  # Return zero if optimization fails\n"})}),"\n",(0,o.jsx)(e.h2,{id:"planning-and-control-integration-node",children:"Planning and Control Integration Node"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist, PoseStamped\nfrom nav_msgs.msg import Path, Odometry\nfrom sensor_msgs.msg import LaserScan\nimport numpy as np\n\nclass PlanningControlNode(Node):\n    def __init__(self):\n        super().__init__('planning_control_node')\n\n        # Publishers and subscribers\n        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)\n        self.path_sub = self.create_subscription(Path, '/global_plan', self.path_callback, 10)\n        self.odom_sub = self.create_subscription(Odometry, '/odom', self.odom_callback, 10)\n        self.scan_sub = self.create_subscription(LaserScan, '/scan', self.scan_callback, 10)\n\n        # Control parameters\n        self.linear_vel = 0.0\n        self.angular_vel = 0.0\n        self.current_path = None\n        self.current_pose = None\n        self.safe_to_move = True\n\n        # Control timer\n        self.control_timer = self.create_timer(0.05, self.control_callback)\n\n        # PID controllers\n        self.linear_pid = PIDController(kp=1.0, ki=0.1, kd=0.05)\n        self.angular_pid = PIDController(kp=2.0, ki=0.1, kd=0.1)\n\n    def path_callback(self, msg):\n        self.current_path = msg.poses\n\n    def odom_callback(self, msg):\n        self.current_pose = msg.pose.pose\n\n    def scan_callback(self, msg):\n        # Simple obstacle detection\n        min_range = min(msg.ranges) if msg.ranges else float('inf')\n        self.safe_to_move = min_range > 0.5  # Safe if obstacle > 0.5m away\n\n    def control_callback(self):\n        if not self.safe_to_move:\n            # Emergency stop\n            cmd_vel = Twist()\n            self.cmd_vel_pub.publish(cmd_vel)\n            return\n\n        if self.current_path is None or self.current_pose is None:\n            return\n\n        # Get next waypoint\n        target = self.get_next_waypoint()\n        if target is None:\n            return\n\n        # Calculate control commands\n        linear_cmd = self.linear_pid.compute(target.linear_distance, 0)\n        angular_cmd = self.angular_pid.compute(target.angular_error, 0)\n\n        # Apply velocity limits\n        linear_cmd = max(-0.5, min(0.5, linear_cmd))  # \xb10.5 m/s\n        angular_cmd = max(-1.0, min(1.0, angular_cmd))  # \xb11.0 rad/s\n\n        # Publish command\n        cmd_vel = Twist()\n        cmd_vel.linear.x = linear_cmd\n        cmd_vel.angular.z = angular_cmd\n        self.cmd_vel_pub.publish(cmd_vel)\n\n    def get_next_waypoint(self):\n        # Simplified waypoint following\n        if not self.current_path:\n            return None\n\n        # Find closest point on path\n        current_pos = [\n            self.current_pose.position.x,\n            self.current_pose.position.y\n        ]\n\n        min_dist = float('inf')\n        closest_point = None\n\n        for pose in self.current_path:\n            dist = np.sqrt(\n                (pose.pose.position.x - current_pos[0])**2 +\n                (pose.pose.position.y - current_pos[1])**2\n            )\n            if dist < min_dist:\n                min_dist = dist\n                closest_point = pose\n\n        if closest_point:\n            # Calculate required heading\n            dx = closest_point.pose.position.x - current_pos[0]\n            dy = closest_point.pose.position.y - current_pos[1]\n            target_angle = np.arctan2(dy, dx)\n\n            # Current robot angle\n            current_angle = self.get_yaw_from_quaternion(self.current_pose.orientation)\n\n            # Angular error\n            angular_error = target_angle - current_angle\n\n            return type('Waypoint', (), {\n                'linear_distance': min_dist,\n                'angular_error': angular_error\n            })()\n\n        return None\n\n    def get_yaw_from_quaternion(self, quat):\n        # Convert quaternion to yaw angle\n        siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)\n        cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)\n        return np.arctan2(siny_cosp, cosy_cosp)\n"})}),"\n",(0,o.jsx)(e.h2,{id:"exercise-tasks",children:"Exercise Tasks"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Implement the A* path planner and test it with different maps"}),"\n",(0,o.jsx)(e.li,{children:"Create a DWA local planner for obstacle avoidance"}),"\n",(0,o.jsx)(e.li,{children:"Implement PID controllers for motion control"}),"\n",(0,o.jsx)(e.li,{children:"Test the complete planning-control pipeline in Isaac Sim"}),"\n",(0,o.jsx)(e.li,{children:"Evaluate planning and control performance metrics"}),"\n",(0,o.jsx)(e.li,{children:"Optimize controller parameters for better performance"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"performance-evaluation",children:"Performance Evaluation"}),"\n",(0,o.jsx)(e.h3,{id:"control-performance-metrics",children:"Control Performance Metrics"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"class ControlPerformanceEvaluator:\n    def __init__(self):\n        self.path_errors = []\n        self.control_efforts = []\n        self.execution_times = []\n\n    def evaluate_tracking(self, desired_trajectory, actual_trajectory):\n        # Calculate tracking error\n        errors = []\n        for i in range(min(len(desired_trajectory), len(actual_trajectory))):\n            error = np.linalg.norm(\n                np.array(desired_trajectory[i][:2]) -\n                np.array(actual_trajectory[i][:2])\n            )\n            errors.append(error)\n\n        rmse = np.sqrt(np.mean(np.square(errors)))\n        max_error = np.max(errors)\n\n        return rmse, max_error\n\n    def evaluate_efficiency(self, control_commands):\n        # Calculate control effort\n        effort = np.sum(np.abs(control_commands))\n        return effort\n"})}),"\n",(0,o.jsx)(e.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,o.jsx)(e.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Path planning failures"}),": Check map resolution and obstacle inflation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Control instability"}),": Tune PID parameters appropriately"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Collision issues"}),": Increase safety margins in local planner"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Performance problems"}),": Optimize algorithm complexity"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"In this lab, you learned to implement planning and control systems for robot AI. You created global and local planners, implemented various control algorithms, and integrated them with perception systems. These components form the core of autonomous robot navigation and manipulation."})]})}function _(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(p,{...n})}):p(n)}},8453(n,e,t){t.d(e,{R:()=>s,x:()=>l});var o=t(6540);const r={},a=o.createContext(r);function s(n){const e=o.useContext(a);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),o.createElement(a.Provider,{value:e},n.children)}}}]);